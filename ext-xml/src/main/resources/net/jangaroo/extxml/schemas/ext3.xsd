<?xml version="1.0" encoding="UTF-8"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://extjs.com/ext3" xmlns:ext="http://extjs.com/ext3" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:complexType name='ext.BoxComponent'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='margins' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>
         <b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the 
         <b>{@link Ext.layout.BorderLayout BorderLayout}</b> or one of the two 
         <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b>
      </p>
      <p>An object containing margins to apply to this BoxComponent in the format:</p>
      <pre>
         <code>{
            top: (top margin),
            right: (right margin),
            bottom: (bottom margin),
            left: (left margin)
            }
         </code>
      </pre>
      <p>May also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
         matches the way CSS processes margin values:
      </p>
      <div class="mdetail-params">
         <ul>
            <li>If there is only one value, it applies to all sides.</li>
            <li>If there are two values, the top and bottom borders are set to the first value and the right and left are set to the second.</li>
            <li>If there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is
               set to the third.
            </li>
            <li>If there are four values, they apply to the top, right, bottom, and left, respectively.</li>
         </ul>
      </div>
      <br></br>
      <br></br> 
      <p>Defaults to:</p>
      <pre>
         <code>{top:0, right:0, bottom:0, left:0}
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='region'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the 
         <b>{@link Ext.layout.BorderLayout BorderLayout}</b> layout manager (e.g. specifying 
         <tt>layout:'border'</tt>).
      </p>
      <br></br>
      <p>See {@link Ext.layout.BorderLayout} also.</p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='margins'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the 
         <b>{@link Ext.layout.BorderLayout BorderLayout}</b> or one of the two 
         <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b>
      </p>
      <p>An object containing margins to apply to this BoxComponent in the format:</p>
      <pre>
         <code>{
            top: (top margin),
            right: (right margin),
            bottom: (bottom margin),
            left: (left margin)
            }
         </code>
      </pre>
      <p>May also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
         matches the way CSS processes margin values:
      </p>
      <div class="mdetail-params">
         <ul>
            <li>If there is only one value, it applies to all sides.</li>
            <li>If there are two values, the top and bottom borders are set to the first value and the right and left are set to the second.</li>
            <li>If there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is
               set to the third.
            </li>
            <li>If there are four values, they apply to the top, right, bottom, and left, respectively.</li>
         </ul>
      </div>
      <br></br>
      <br></br> 
      <p>Defaults to:</p>
      <pre>
         <code>{top:0, right:0, bottom:0, left:0}
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='x'>
          <xs:annotation>
            <xs:documentation>
The local x (left) coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='y'>
          <xs:annotation>
            <xs:documentation>
The local y (top) coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageX'>
          <xs:annotation>
            <xs:documentation>
The page level x coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageY'>
          <xs:annotation>
            <xs:documentation>
The page level y coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='height'>
          <xs:annotation>
            <xs:documentation>
The height of this component in pixels (defaults to auto). 
      <b>Note</b> to express this dimension as a percentage or offset see {@link Ext.Component#anchor}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='width'>
          <xs:annotation>
            <xs:documentation>
The width of this component in pixels (defaults to auto). 
      <b>Note</b> to express this dimension as a percentage or offset see {@link Ext.Component#anchor}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoHeight'>
          <xs:annotation>
            <xs:documentation>

      <p>True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's {@link Ext.Container#layout
         layout manager}. Defaults to false.
      </p>
      <p>
         <b>Note</b>: Although many components inherit this config option, not all will function as expected with a height of 'auto'. Setting
         autoHeight:true means that the browser will manage height based on the element's contents, and that Ext will not manage it
         at all.
      </p>
      <p>If the 
         <i>browser</i> is managing the height, be aware that resizes performed by the browser in response to changes within the structure of the
         Component cannot be detected. Therefore changes to the height might result in elements needing to be synchronized with the
         new height. Example:
      </p>
      <pre>
         <code>var w = new Ext.Window({
            title: 'Window',
            width: 600,
            autoHeight: true,
            items: {
            title: 'Collapse Me',
            height: 400,
            collapsible: true,
            border: false,
            listeners: {
            beforecollapse: function() {
            w.el.shadow.hide();
            },
            beforeexpand: function() {
            w.el.shadow.hide();
            },
            collapse: function() {
            w.syncShadow();
            },
            expand: function() {
            w.syncShadow();
            }
            }
            }
            }).show();
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoWidth'>
          <xs:annotation>
            <xs:documentation>

      <p>True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's {@link Ext.Container#layout
         layout manager}. Defaults to false.
      </p>
      <p>
         <b>Note</b>: Although many components inherit this config option, not all will function as expected with a width of 'auto'. Setting autoWidth:true
         means that the browser will manage width based on the element's contents, and that Ext will not manage it at all.
      </p>
      <p>If the 
         <i>browser</i> is managing the width, be aware that resizes performed by the browser in response to changes within the structure of the
         Component cannot be detected. Therefore changes to the width might result in elements needing to be synchronized with the
         new width. For example, where the target element is:
      </p>
      <pre>
         <code>&lt;div id='grid-container' style='margin-left:25%;width:50%'&gt;&lt;/div&gt;
            
         </code>
      </pre>A Panel rendered into that target element must listen for browser window resize in order to relay its child items when the
      browser changes its width:
      <pre>
         <code>var myPanel = new Ext.Panel({
            renderTo: 'grid-container',
            monitorResize: true, // relay on browser resize
            title: 'Panel',
            height: 400,
            autoWidth: true,
            layout: 'hbox',
            layoutConfig: {
            align: 'stretch'
            },
            defaults: {
            flex: 1
            },
            items: [{
            title: 'Box 1',
            }, {
            title: 'Box 2'
            }, {
            title: 'Box 3'
            }],
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='box' type='ext:ext.BoxComponent' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>

      <p>Base class for any {@link Ext.Component Component} that is to be sized as a box, using width and height.</p>
      <p>BoxComponent provides automatic box model adjustments for sizing and positioning and will work correctly within the Component
         rendering model.
      </p>
      <p>A BoxComponent may be created as a custom Component which encapsulates any HTML element, either a pre-existing element, or
         one that is created to your specifications at render time. Usually, to participate in layouts, a Component will need to be
         a 
         <b>Box</b>Component in order to have its width and height managed.
      </p>
      <p>To use a pre-existing element as a BoxComponent, configure it so that you preset the 
         <b>el</b> property to the element to reference:
      </p>
      <pre>
         <code>var pageHeader = new Ext.BoxComponent({
            el: 'my-header-div'
            });
         </code>
      </pre>This may then be {@link Ext.Container#add added} to a {@link Ext.Container Container} as a child item.
      <br></br>
      <br></br> 
      <p>To create a BoxComponent based around a HTML element to be created at render time, use the {@link Ext.Component#autoEl autoEl}
         config option which takes the form of a {@link Ext.DomHelper DomHelper} specification:
      </p>
      <pre>
         <code>var myImage = new Ext.BoxComponent({
            autoEl: {
            tag: 'img',
            src: '/images/my-image.jpg'
            }
            });
         </code>
      </pre>
      <br></br>
      <br></br>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Spacer'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='spacer' type='ext:ext.Spacer' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>

      <p>Used to provide a sizable space in a layout.</p>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Button'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the button is clicked (can be used instead of click event). The handler is passed the following parameters:
      <div class="mdetail-params">
         <ul>
            <li>
               <code>b</code> : Button
               <div class="sub-desc">This Button.</div>
            </li>
            <li>
               <code>e</code> : EventObject
               <div class="sub-desc">The click event.</div>
            </li>
         </ul>
      </div>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (
      <tt>
         <b>this</b>
      </tt> reference) in which the handler is executed. Defaults to this Button.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='tooltip' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='repeat' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    True to repeat fire the click event while the mouse is down. This can also be a {@link Ext.util.ClickRepeater ClickRepeater}
      config object (defaults to false).
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='toggleHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Function called when a Button with {@link #enableToggle} set to true is clicked. Two arguments are passed:
      <ul class="mdetail-params">
         <li>
            <b>button</b> : Ext.Button
            <div class="sub-desc">this Button object</div>
         </li>
         <li>
            <b>state</b> : Boolean
            <div class="sub-desc">The next state if the Button, true means pressed.</div>
         </li>
      </ul>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='menu' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to undefined).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='template' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (Optional) 
      <p>A {@link Ext.Template Template} used to create the Button's DOM structure.</p>Instances, or subclasses which need a different DOM structure may provide a different template layout in conjunction with
      an implementation of {@link #getTemplateArgs}. @type Ext.Template @property template
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The button text to be used as innerHTML (html tags are accepted)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='icon'>
          <xs:annotation>
            <xs:documentation>
The path to an image to display in the button (the image will be set as the background-image CSS property of the button by
      default, so if you want a mixed icon/text button, set cls:'x-btn-text-icon')
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
A function called when the button is clicked (can be used instead of click event). The handler is passed the following parameters:
      <div class="mdetail-params">
         <ul>
            <li>
               <code>b</code> : Button
               <div class="sub-desc">This Button.</div>
            </li>
            <li>
               <code>e</code> : EventObject
               <div class="sub-desc">The click event.</div>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (
      <tt>
         <b>this</b>
      </tt> reference) in which the handler is executed. Defaults to this Button.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width for this button (used to give a set of buttons a common width). See also {@link Ext.Panel}.
      <tt>{@link Ext.Panel#minButtonWidth minButtonWidth}</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tooltip'>
          <xs:annotation>
            <xs:documentation>
The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='pressed'>
          <xs:annotation>
            <xs:documentation>
True to start pressed (only if enableToggle = true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toggleGroup'>
          <xs:annotation>
            <xs:documentation>
The group this toggle button is a member of (only 1 per group can be pressed)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='repeat'>
          <xs:annotation>
            <xs:documentation>
True to repeat fire the click event while the mouse is down. This can also be a {@link Ext.util.ClickRepeater ClickRepeater}
      config object (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabIndex'>
          <xs:annotation>
            <xs:documentation>
Set a DOM tabIndex for this button (defaults to undefined)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowDepress'>
          <xs:annotation>
            <xs:documentation>
False to not allow a pressed Button to be depressed (defaults to undefined). Only valid when {@link #enableToggle} is true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableToggle'>
          <xs:annotation>
            <xs:documentation>
True to enable pressed/not pressed toggling (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toggleHandler'>
          <xs:annotation>
            <xs:documentation>
Function called when a Button with {@link #enableToggle} set to true is clicked. Two arguments are passed:
      <ul class="mdetail-params">
         <li>
            <b>button</b> : Ext.Button
            <div class="sub-desc">this Button object</div>
         </li>
         <li>
            <b>state</b> : Boolean
            <div class="sub-desc">The next state if the Button, true means pressed.</div>
         </li>
      </ul>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='menu'>
          <xs:annotation>
            <xs:documentation>
Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='menuAlign'>
          <xs:annotation>
            <xs:documentation>
The position to align the menu to (see {@link Ext.Element#alignTo} for more details, defaults to 'tl-bl?').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overflowText'>
          <xs:annotation>
            <xs:documentation>
If used in a {@link Ext.Toolbar Toolbar}, the text to be used if this item is shown in the overflow menu. See also {@link
      Ext.Toolbar.Item}.
      <code>{@link Ext.Toolbar.Item#overflowText overflowText}</code>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
A css class which sets a background image to be used as the icon for this button
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='type'>
          <xs:annotation>
            <xs:documentation>
submit, reset or button - defaults to 'button'
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='clickEvent'>
          <xs:annotation>
            <xs:documentation>
The type of event to map to the button's event handler (defaults to 'click')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='handleMouseEvents'>
          <xs:annotation>
            <xs:documentation>
False to disable visual cues on mouseover, mouseout and mousedown (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tooltipType'>
          <xs:annotation>
            <xs:documentation>
The type of tooltip to use. Either 'qtip' (default) for QuickTips or 'title' for title attribute.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttonSelector'>
          <xs:annotation>
            <xs:documentation>

      <p>(Optional) A {@link Ext.DomQuery DomQuery} selector which is used to extract the active, clickable element from the DOM structure
         created.
      </p>
      <p>When a custom {@link #template} is used, you must ensure that this selector results in the selection of a focussable element.</p>
      <p>Defaults to 
         <b>
            <tt>"button:first-child"</tt>
         </b>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scale'>
          <xs:annotation>
            <xs:documentation>

      <p>(Optional) The size of the Button. Three values are allowed:</p>
      <ul class="mdetail-params">
         <li>'small'
            <div class="sub-desc">Results in the button element being 16px high.</div>
         </li>
         <li>'medium'
            <div class="sub-desc">Results in the button element being 24px high.</div>
         </li>
         <li>'large'
            <div class="sub-desc">Results in the button element being 32px high.</div>
         </li>
      </ul>
      <p>Defaults to 
         <b>
            <tt>'small'</tt>
         </b>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconAlign'>
          <xs:annotation>
            <xs:documentation>

      <p>(Optional) The side of the Button box to render the icon. Four values are allowed:</p>
      <ul class="mdetail-params">
         <li>'top'</li>
         <li>'right'</li>
         <li>'bottom'</li>
         <li>'left'</li>
      </ul>
      <p>Defaults to 
         <b>
            <tt>'left'</tt>
         </b>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='arrowAlign'>
          <xs:annotation>
            <xs:documentation>

      <p>(Optional) The side of the Button box to render the arrow if the button has an associated {@link #menu}. Two values are allowed:</p>
      <ul class="mdetail-params">
         <li>'right'</li>
         <li>'bottom'</li>
      </ul>
      <p>Defaults to 
         <b>
            <tt>'right'</tt>
         </b>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='template'>
          <xs:annotation>
            <xs:documentation>
(Optional) 
      <p>A {@link Ext.Template Template} used to create the Button's DOM structure.</p>Instances, or subclasses which need a different DOM structure may provide a different template layout in conjunction with
      an implementation of {@link #getTemplateArgs}. @type Ext.Template @property template
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='button' type='ext:ext.Button' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Simple Button class
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ButtonGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:int' name='columns'>
          <xs:annotation>
            <xs:documentation>
The 
      <tt>columns</tt> configuration property passed to the {@link #layout configured layout manager}. See {@link Ext.layout.TableLayout#columns}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='buttongroup' type='ext:ext.ButtonGroup' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
Container for a group of buttons. Example usage: 
      <pre>
         <code>var p = new Ext.Panel({
            title: 'Panel with Button Group',
            width: 300,
            height:200,
            renderTo: document.body,
            html: 'whatever',
            tbar: [{
            xtype: 'buttongroup',
            {@link #columns}: 3,
            title: 'Clipboard',
            items: [{
            text: 'Paste',
            scale: 'large',
            rowspan: 3, iconCls: 'add',
            iconAlign: 'top',
            cls: 'x-btn-as-arrow'
            },{
            xtype:'splitbutton',
            text: 'Menu Button',
            scale: 'large',
            rowspan: 3,
            iconCls: 'add',
            iconAlign: 'top',
            arrowAlign:'bottom',
            menu: [{text: 'Menu Item 1'}]
            },{
            xtype:'splitbutton', text: 'Cut', iconCls: 'add16', menu: [{text: 'Cut Menu Item'}]
            },{
            text: 'Copy', iconCls: 'add16'
            },{
            text: 'Format', iconCls: 'add16'
            }]
            }]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.Chart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.FlashComponent'>
        <xs:sequence>
            <xs:element name='chartStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Sets styles for this chart. Contains a number of default values. Modifying this property will override the base styles on
      the chart.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='extraStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Contains extra styles that will be added or overwritten to the default chartStyle. Defaults to 
      <tt>null</tt>.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='chartStyle'>
          <xs:annotation>
            <xs:documentation>
Sets styles for this chart. Contains a number of default values. Modifying this property will override the base styles on
      the chart.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='extraStyle'>
          <xs:annotation>
            <xs:documentation>
Contains extra styles that will be added or overwritten to the default chartStyle. Defaults to 
      <tt>null</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableCaching'>
          <xs:annotation>
            <xs:documentation>
True to add a "cache buster" to the end of the chart url. Defaults to true for Opera and IE.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='chart' type='ext:ext.chart.Chart' substitutionGroup='ext:flash'>
    <xs:annotation>
      <xs:documentation>
The Ext.chart package provides the capability to visualize data with flash based charting. Each chart binds directly to an
      Ext.data.Store enabling automatic updates of the chart.
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.PieChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.Chart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='piechart' type='ext:ext.chart.PieChart' substitutionGroup='ext:chart'>
    <xs:annotation>
      <xs:documentation>

      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.CartesianChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.Chart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='cartesianchart' type='ext:ext.chart.CartesianChart' substitutionGroup='ext:chart'>
    <xs:annotation>
      <xs:documentation>

      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.LineChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='linechart' type='ext:ext.chart.LineChart' substitutionGroup='ext:cartesianchart'>
    <xs:annotation>
      <xs:documentation>

      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.ColumnChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='columnchart' type='ext:ext.chart.ColumnChart' substitutionGroup='ext:cartesianchart'>
    <xs:annotation>
      <xs:documentation>

      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.StackedColumnChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='stackedcolumnchart' type='ext:ext.chart.StackedColumnChart' substitutionGroup='ext:cartesianchart'>
    <xs:annotation>
      <xs:documentation>

      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.BarChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='barchart' type='ext:ext.chart.BarChart' substitutionGroup='ext:cartesianchart'>
    <xs:annotation>
      <xs:documentation>

      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.StackedBarChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='stackedbarchart' type='ext:ext.chart.StackedBarChart' substitutionGroup='ext:cartesianchart'>
    <xs:annotation>
      <xs:documentation>

      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.FlashComponent'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='flashVersion'>
          <xs:annotation>
            <xs:documentation>
Indicates the version the flash content was published for. Defaults to 
      <tt>'9.0.45'</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='backgroundColor'>
          <xs:annotation>
            <xs:documentation>
The background color of the chart. Defaults to 
      <tt>'#ffffff'</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='wmode'>
          <xs:annotation>
            <xs:documentation>
The wmode of the flash object. This can be used to control layering. Defaults to 
      <tt>'opaque'</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='url'>
          <xs:annotation>
            <xs:documentation>
The URL of the chart to include. Defaults to 
      <tt>undefined</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='expressInstall'>
          <xs:annotation>
            <xs:documentation>
True to prompt the user to install flash if not installed. Note that this uses Ext.FlashComponent.EXPRESS_INSTALL_URL, which
      should be set to the local resource. Defaults to 
      <tt>false</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='flash' type='ext:ext.FlashComponent' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>

      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ColorPalette'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
An existing XTemplate instance to be used in place of the default template for rendering the component.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
The initial color to highlight (should be a valid 6-digit color hex code without the # symbol). Note that the hex codes are
      case-sensitive.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowReselect'>
          <xs:annotation>
            <xs:documentation>
If set to true then reselecting a color that is already selected fires the {@link #select} event
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='colorpalette' type='ext:ext.ColorPalette' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
Simple color palette class for choosing colors. The palette can be rendered to any container.
      <br></br>Here's an example of typical usage: 
      <pre>
         <code>var cp = new Ext.ColorPalette({value:'993300'});  // initial selected color
            cp.render('my-div');
            
            cp.on('select', function(palette, selColor){
            // do something with selColor
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Component'>
        <xs:sequence>
            <xs:element name='plugins' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An object or array of objects that will provide custom functionality for this component. The only requirement for a valid
      plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is created, if any
      plugins are available, the component will call the init method on each plugin, passing a reference to itself. Each plugin
      can then call methods or respond to events on the component as needed to provide its functionality.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='applyTo' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in the
         document that specifies some structural markup for this component.
      </p>
      <div>
         <ul>
            <li>
               <b>Description</b> : 
               <div style="margin-left: 2em">When 
                  <tt>applyTo</tt> is used, constituent parts of the component can also be specified by id or CSS class name within the main element, and the
                  component being created may attempt to create its subcomponents from that markup if applicable.
               </div>
            </li>
            <li>
               <b>Notes</b> : 
               <div style="margin-left: 2em">
                  <div class="sub-desc">When using this config, a call to render() is not required.</div>
                  <div class="sub-desc">If applyTo is specified, any value passed for {@link #renderTo} will be ignored and the target element's parent node will
                     automatically be used as the component's container.
                  </div>
               </div>
            </li>
         </ul>
      </div>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='renderTo' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>Specify the id of the element, a DOM element or an existing Element that this component will be rendered into.</p>
      <div>
         <ul>
            <li>
               <b>Notes</b> : 
               <div style="margin-left: 2em">
                  <div class="sub-desc">Do 
                     <u>not</u> use this option if the Component is to be a child item of a {@link Ext.Container Container}. It is the responsibility of
                     the {@link Ext.Container Container}'s {@link Ext.Container#layout layout manager} to render and manage its child items.
                  </div>
                  <div class="sub-desc">When using this config, a call to render() is not required.</div>
               </div>
            </li>
         </ul>
      </div>
      <p>See 
         <tt>{@link #render}</tt> also.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='stateEvents' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>An array of events that, when fired, should trigger this component to save its state (defaults to none). 
         <code>stateEvents</code> may be any type of event supported by this component, including browser or custom events (e.g., 
         <tt>['click', 'customerchange']</tt>).
      </p>
      <p>See 
         <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoEl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A tag name or {@link Ext.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will encapsulate this Component.</p>
      <p>You do not normally need to specify this. For the base classes {@link Ext.Component}, {@link Ext.BoxComponent}, and {@link
         Ext.Container}, this defaults to 
         <b>
            <tt>'div'</tt>
         </b>. The more complex Ext classes use a more complex DOM structure created by their own onRender methods.
      </p>
      <p>This is intended to allow the developer to create application-specific utility Components encapsulated by different DOM elements.
         Example usage:
      </p>
      <pre>
         <code>{
            xtype: 'box',
            autoEl: {
            tag: 'img',
            src: 'http://www.example.com/example.jpg'
            }
            }, {
            xtype: 'box',
            autoEl: {
            tag: 'blockquote',
            html: 'autoEl is cool!'
            }
            }, {
            xtype: 'container',
            autoEl: 'ul',
            cls: 'ux-unordered-list',
            items: {
            xtype: 'box',
            autoEl: 'li',
            html: 'First list item'
            }
            }
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='fieldLabel'>
          <xs:annotation>
            <xs:documentation>

      <p>The label text to display next to this Component (defaults to '').</p>
      <br></br>
      <p>
         <b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use the 
         <b>{@link Ext.layout.FormLayout FormLayout}</b> layout manager (e.g. {@link Ext.form.FormPanel} or specifying 
         <tt>layout:'form'</tt>).
      </p>
      <br></br>
      <p>Also see 
         <tt>{@link #hideLabel}</tt> and {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.
      </p>Example use:
      <pre>
         <code>new Ext.FormPanel({
            height: 100,
            renderTo: Ext.getBody(),
            items: [{
            xtype: 'textfield',
            fieldLabel: 'Name'
            }]
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelStyle'>
          <xs:annotation>
            <xs:documentation>

      <p>A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value if
         set (e.g., 
         <tt>{@link Ext.layout.FormLayout#labelStyle}</tt> , or '').
      </p>
      <br></br>
      <p>
         <b>Note</b>: see the note for 
         <code>{@link #clearCls}</code>.
      </p>
      <br></br>
      <p>Also see 
         <code>{@link #hideLabel}</code> and 
         <code>{@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.</code>
      </p>Example use:
      <pre>
         <code>new Ext.FormPanel({
            height: 100,
            renderTo: Ext.getBody(),
            items: [{
            xtype: 'textfield',
            fieldLabel: 'Name',
            labelStyle: 'font-weight:bold;'
            }]
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelSeparator'>
          <xs:annotation>
            <xs:documentation>

      <p>The separator to display after the text of each 
         <tt>{@link #fieldLabel}</tt>. This property may be configured at various levels. The order of precedence is:
      </p>
      <div class="mdetail-params">
         <ul>
            <li>field / component level</li>
            <li>container level</li>
            <li>{@link Ext.layout.FormLayout#labelSeparator layout level} (defaults to colon 
               <tt>':'</tt>)
            </li>
         </ul>
      </div>To display no separator for this field's label specify empty string ''.
      <br></br>
      <br></br> 
      <br></br>
      <p>
         <b>Note</b>: see the note for 
         <tt>{@link #clearCls}</tt>.
      </p>
      <br></br>
      <p>Also see 
         <tt>{@link #hideLabel}</tt> and {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.
      </p>Example use:
      <pre>
         <code>new Ext.FormPanel({
            height: 100,
            renderTo: Ext.getBody(),
            layoutConfig: {
            labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
            },
            {@link Ext.layout.FormLayout#labelSeparator labelSeparator}: '&gt;&gt;',     // config at container level
            items: [{
            xtype: 'textfield',
            fieldLabel: 'Field 1',
            labelSeparator: '...' // field/component level config supersedes others
            },{
            xtype: 'textfield',
            fieldLabel: 'Field 2' // labelSeparator will be '='
            }]
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideLabel'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <tt>true</tt> to completely hide the label element ({@link #fieldLabel label} and {@link #labelSeparator separator}). Defaults to 
         <tt>false</tt>. By default, even if you do not specify a 
         <tt>{@link #fieldLabel}</tt> the space will still be reserved so that the field will line up with other fields that do have labels. Setting this to 
         <tt>true</tt> will cause the field to not reserve that space.
      </p>
      <br></br>
      <p>
         <b>Note</b>: see the note for 
         <tt>{@link #clearCls}</tt>.
      </p>
      <br></br>Example use:
      <pre>
         <code>new Ext.FormPanel({
            height: 100,
            renderTo: Ext.getBody(),
            items: [{
            xtype: 'textfield'
            hideLabel: true
            }]
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='clearCls'>
          <xs:annotation>
            <xs:documentation>

      <p>The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide field
         clearing (defaults to 
         <tt>'x-form-clear-left'</tt>).
      </p>
      <br></br>
      <p>
         <b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use the 
         <b>{@link Ext.layout.FormLayout FormLayout}</b> layout manager (e.g. {@link Ext.form.FormPanel} or specifying 
         <tt>layout:'form'</tt>) and either a 
         <tt>{@link #fieldLabel}</tt> is specified or 
         <tt>isFormField=true</tt> is specified.
      </p>
      <br></br>
      <p>See {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl} also.</p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemCls'>
          <xs:annotation>
            <xs:documentation>

      <p>An additional CSS class to apply to the div wrapping the form item element of this field. If supplied, 
         <tt>itemCls</tt> at the 
         <b>field</b> level will override the default 
         <tt>itemCls</tt> supplied at the 
         <b>container</b> level. The value specified for 
         <tt>itemCls</tt> will be added to the default class (
         <tt>'x-form-item'</tt>).
      </p>
      <p>Since it is applied to the item wrapper (see {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}),
         it allows you to write standard CSS rules that can apply to the field, the label (if specified), or any other element within
         the markup for the field.
      </p>
      <br></br>
      <p>
         <b>Note</b>: see the note for 
         <tt>{@link #fieldLabel}</tt>.
      </p>
      <br></br>Example use:
      <pre>
         <code>// Apply a style to the field's label:
            &lt;style&gt;
            .required .x-form-item-label {font-weight:bold;color:red;}
            &lt;/style&gt;
            
            new Ext.FormPanel({
            height: 100,
            renderTo: Ext.getBody(),
            items: [{
            xtype: 'textfield',
            fieldLabel: 'Name',
            itemCls: 'required' //this label will be styled
            },{
            xtype: 'textfield',
            fieldLabel: 'Favorite Color'
            }]
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='anchor'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use an 
         <b>{@link Ext.layout.AnchorLayout AnchorLayout}</b> based layout manager, for example:
      </p>
      <div class="mdetail-params">
         <ul>
            <li>{@link Ext.form.FormPanel}</li>
            <li>specifying 
               <code>layout: 'anchor' // or 'form', or 'absolute'</code>
            </li>
         </ul>
      </div>
      <br></br>
      <br></br> 
      <p>See {@link Ext.layout.AnchorLayout}.{@link Ext.layout.AnchorLayout#anchor anchor} also.</p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='id'>
          <xs:annotation>
            <xs:documentation>

      <p>The 
         <b>unique</b> id of this component (defaults to an {@link #getId auto-assigned id}). You should assign an id if you need to be able to
         access the component later and you do not have an object reference available (e.g., using {@link Ext}.{@link Ext#getCmp getCmp}).
      </p>
      <p>Note that this id will also be used as the element id for the containing HTML element that is rendered to the page for this
         component. This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also
         to select sub-elements using this component's id as the parent.
      </p>
      <p>
         <b>Note</b>: to avoid complications imposed by a unique 
         <tt>id</tt> also see 
         <code>{@link #itemId}</code> and 
         <code>{@link #ref}</code>.
      </p>
      <p>
         <b>Note</b>: to access the container of an item see 
         <code>{@link #ownerCt}</code>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemId'>
          <xs:annotation>
            <xs:documentation>

      <p>An 
         <tt>itemId</tt> can be used as an alternative way to get a reference to a component when no object reference is available. Instead of using
         an 
         <code>{@link #id}</code> with {@link Ext}.{@link Ext#getCmp getCmp}, use 
         <code>itemId</code> with {@link Ext.Container}.{@link Ext.Container#getComponent getComponent} which will retrieve 
         <code>itemId</code>'s or 
         <tt>{@link #id}</tt>'s. Since 
         <code>itemId</code>'s are an index to the container's internal MixedCollection, the 
         <code>itemId</code> is scoped locally to the container -- avoiding potential conflicts with {@link Ext.ComponentMgr} which requires a 
         <b>unique</b> 
         <code>{@link #id}</code>.
      </p>
      <pre>
         <code>var c = new Ext.Panel({ //
            {@link Ext.BoxComponent#height height}: 300,
            {@link #renderTo}: document.body,
            {@link Ext.Container#layout layout}: 'auto',
            {@link Ext.Container#items items}: [
            {
            itemId: 'p1',
            {@link Ext.Panel#title title}: 'Panel 1',
            {@link Ext.BoxComponent#height height}: 150
            },
            {
            itemId: 'p2',
            {@link Ext.Panel#title title}: 'Panel 2',
            {@link Ext.BoxComponent#height height}: 150
            }
            ]
            })
            p1 = c.{@link Ext.Container#getComponent getComponent}('p1'); // not the same as {@link Ext#getCmp Ext.getCmp()}
            p2 = p1.{@link #ownerCt}.{@link Ext.Container#getComponent getComponent}('p2'); // reference via a sibling
            
         </code>
      </pre>
      <p>Also see 
         <tt>{@link #id}</tt> and 
         <code>{@link #ref}</code>.
      </p>
      <p>
         <b>Note</b>: to access the container of an item see 
         <tt>{@link #ownerCt}</tt>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='xtype'>
          <xs:annotation>
            <xs:documentation>
The registered 
      <tt>xtype</tt> to create. This config option is not used when passing a config object into a constructor. This config option is used only
      when lazy instantiation is being used, and a child item of a Container is being specified not as a fully instantiated Component,
      but as a 
      <i>Component config object</i>. The 
      <tt>xtype</tt> will be looked up at render time up to determine what type of child Component to create.
      <br></br>
      <br></br>The predefined xtypes are listed {@link Ext.Component here}. 
      <br></br>
      <br></br>If you subclass Components to create your own Components, you may register them using {@link Ext.ComponentMgr#registerType}
      in order to be able to take advantage of lazy instantiation and rendering.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ptype'>
          <xs:annotation>
            <xs:documentation>
The registered 
      <tt>ptype</tt> to create. This config option is not used when passing a config object into a constructor. This config option is used only
      when lazy instantiation is being used, and a Plugin is being specified not as a fully instantiated Component, but as a 
      <i>Component config object</i>. The 
      <tt>ptype</tt> will be looked up at render time up to determine what type of Plugin to create.
      <br></br>
      <br></br>If you create your own Plugins, you may register them using {@link Ext.ComponentMgr#registerPlugin} in order to be able to
      take advantage of lazy instantiation and rendering.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cls'>
          <xs:annotation>
            <xs:documentation>
An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for adding
      customized styles to the component or any of its children using standard CSS rules.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overCls'>
          <xs:annotation>
            <xs:documentation>
An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and removed
      when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles to the component
      or any of its children using standard CSS rules.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='style'>
          <xs:annotation>
            <xs:documentation>
A custom style specification to be applied to this component's Element. Should be a valid argument to {@link Ext.Element#applyStyles}.
      
      <pre>
         <code>new Ext.Panel({
            title: 'Some Title',
            renderTo: Ext.getBody(),
            width: 400, height: 300,
            layout: 'form',
            items: [{
            xtype: 'textarea',
            style: {
            width: '95%',
            marginBottom: '10px'
            }
            },
            new Ext.Button({
            text: 'Send',
            minWidth: '100',
            style: {
            marginBottom: '10px'
            }
            })
            ]
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ctCls'>
          <xs:annotation>
            <xs:documentation>

      <p>An optional extra CSS class that will be added to this component's container. This can be useful for adding customized styles
         to the container or any of its children using standard CSS rules. See {@link Ext.layout.ContainerLayout}.{@link Ext.layout.ContainerLayout#extraCls
         extraCls} also.
      </p>
      <p>
         <b>Note</b>: 
         <tt>ctCls</tt> defaults to 
         <tt>''</tt> except for the following class which assigns a value by default:
      </p>
      <div class="mdetail-params">
         <ul>
            <li>{@link Ext.layout.Box Box Layout} : 
               <tt>'x-box-layout-ct'</tt>
            </li>
         </ul>
      </div>To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout (Hbox and Vbox):
      <pre>
         <code>ctCls: 'x-box-layout-ct custom-class'
            
         </code>
      </pre>
      <br></br>
      <br></br>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disabled'>
          <xs:annotation>
            <xs:documentation>
Render this component disabled (default is false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hidden'>
          <xs:annotation>
            <xs:documentation>
Render this component hidden (default is false). If 
      <tt>true</tt>, the {@link #hide} method will be called internally.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='plugins'>
          <xs:annotation>
            <xs:documentation>
An object or array of objects that will provide custom functionality for this component. The only requirement for a valid
      plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is created, if any
      plugins are available, the component will call the init method on each plugin, passing a reference to itself. Each plugin
      can then call methods or respond to events on the component as needed to provide its functionality.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='applyTo'>
          <xs:annotation>
            <xs:documentation>

      <p>Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in the
         document that specifies some structural markup for this component.
      </p>
      <div>
         <ul>
            <li>
               <b>Description</b> : 
               <div style="margin-left: 2em">When 
                  <tt>applyTo</tt> is used, constituent parts of the component can also be specified by id or CSS class name within the main element, and the
                  component being created may attempt to create its subcomponents from that markup if applicable.
               </div>
            </li>
            <li>
               <b>Notes</b> : 
               <div style="margin-left: 2em">
                  <div class="sub-desc">When using this config, a call to render() is not required.</div>
                  <div class="sub-desc">If applyTo is specified, any value passed for {@link #renderTo} will be ignored and the target element's parent node will
                     automatically be used as the component's container.
                  </div>
               </div>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='renderTo'>
          <xs:annotation>
            <xs:documentation>

      <p>Specify the id of the element, a DOM element or an existing Element that this component will be rendered into.</p>
      <div>
         <ul>
            <li>
               <b>Notes</b> : 
               <div style="margin-left: 2em">
                  <div class="sub-desc">Do 
                     <u>not</u> use this option if the Component is to be a child item of a {@link Ext.Container Container}. It is the responsibility of
                     the {@link Ext.Container Container}'s {@link Ext.Container#layout layout manager} to render and manage its child items.
                  </div>
                  <div class="sub-desc">When using this config, a call to render() is not required.</div>
               </div>
            </li>
         </ul>
      </div>
      <p>See 
         <tt>{@link #render}</tt> also.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='stateful'>
          <xs:annotation>
            <xs:documentation>

      <p>A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup. The
         component must have either a 
         <code>{@link #stateId}</code> or 
         <code>{@link #id}</code> assigned for state to be managed. Auto-generated ids are not guaranteed to be stable across page loads and cannot be relied
         upon to save and restore the same state for a component.
      </p>
      <p>For state saving to work, the state manager's provider must have been set to an implementation of {@link Ext.state.Provider}
         which overrides the {@link Ext.state.Provider#set set} and {@link Ext.state.Provider#get get} methods to save and recall name/value
         pairs. A built-in implementation, {@link Ext.state.CookieProvider} is available.
      </p>
      <p>To set the state provider for the current page:</p>
      <pre>
         <code>Ext.state.Manager.setProvider(new Ext.state.CookieProvider({
            expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
            }));
            
         </code>
      </pre>
      <p>A stateful Component attempts to save state when one of the events listed in the 
         <code>{@link #stateEvents}</code> configuration fires.
      </p>
      <p>To save state, a stateful Component first serializes its state by calling 
         <b>
            <code>getState</code>
         </b>. By default, this function does nothing. The developer must provide an implementation which returns an object hash which
         represents the Component's restorable state.
      </p>
      <p>The value yielded by getState is passed to {@link Ext.state.Manager#set} which uses the configured {@link Ext.state.Provider}
         to save the object keyed by the Component's 
         <code>{@link stateId}</code>, or, if that is not specified, its 
         <code>{@link #id}</code>.
      </p>
      <p>During construction, a stateful Component attempts to 
         <i>restore</i> its state by calling {@link Ext.state.Manager#get} passing the 
         <code>{@link #stateId}</code>, or, if that is not specified, the 
         <code>{@link #id}</code>.
      </p>
      <p>The resulting object is passed to 
         <b>
            <code>applyState</code>
         </b>. The default implementation of 
         <code>applyState</code> simply copies properties into the object, but a developer may override this to support more behaviour.
      </p>
      <p>You can perform extra processing on state save and restore by attaching handlers to the {@link #beforestaterestore}, {@link
         #staterestore}, {@link #beforestatesave} and {@link #statesave} events.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stateId'>
          <xs:annotation>
            <xs:documentation>
The unique id for this component to use for state management purposes (defaults to the component id if one was set, otherwise
      null if the component is using a generated id). 
      <p>See 
         <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stateEvents'>
          <xs:annotation>
            <xs:documentation>

      <p>An array of events that, when fired, should trigger this component to save its state (defaults to none). 
         <code>stateEvents</code> may be any type of event supported by this component, including browser or custom events (e.g., 
         <tt>['click', 'customerchange']</tt>).
      </p>
      <p>See 
         <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoEl'>
          <xs:annotation>
            <xs:documentation>

      <p>A tag name or {@link Ext.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will encapsulate this Component.</p>
      <p>You do not normally need to specify this. For the base classes {@link Ext.Component}, {@link Ext.BoxComponent}, and {@link
         Ext.Container}, this defaults to 
         <b>
            <tt>'div'</tt>
         </b>. The more complex Ext classes use a more complex DOM structure created by their own onRender methods.
      </p>
      <p>This is intended to allow the developer to create application-specific utility Components encapsulated by different DOM elements.
         Example usage:
      </p>
      <pre>
         <code>{
            xtype: 'box',
            autoEl: {
            tag: 'img',
            src: 'http://www.example.com/example.jpg'
            }
            }, {
            xtype: 'box',
            autoEl: {
            tag: 'blockquote',
            html: 'autoEl is cool!'
            }
            }, {
            xtype: 'container',
            autoEl: 'ul',
            cls: 'ux-unordered-list',
            items: {
            xtype: 'box',
            autoEl: 'li',
            html: 'First list item'
            }
            }
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledClass'>
          <xs:annotation>
            <xs:documentation>
CSS class added to the component when it is disabled (defaults to 'x-item-disabled').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowDomMove'>
          <xs:annotation>
            <xs:documentation>
Whether the component can move the Dom node when rendering (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoShow'>
          <xs:annotation>
            <xs:documentation>
True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render (defaults
      to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hideMode'>
          <xs:annotation>
            <xs:documentation>

      <p>How this component should be hidden. Supported values are 
         <tt>'visibility'</tt> (css visibility), 
         <tt>'offsets'</tt> (negative offset position) and 
         <tt>'display'</tt> (css display).
      </p>
      <br></br>
      <p>
         <b>Note</b>: the default of 
         <tt>'display'</tt> is generally preferred since items are automatically laid out when they are first shown (no sizing is done while hidden).
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideParent'>
          <xs:annotation>
            <xs:documentation>
True to hide and show the component's container when hide/show is called on the component, false to hide and show the component
      itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by setting hide:true
      on the button when adding it to its parent container.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ref'>
          <xs:annotation>
            <xs:documentation>

      <p>A path specification, relative to the Component's {@link #ownerCt} specifying into which ancestor Container to place a named
         reference to this Component.
      </p>
      <p>The ancestor axis can be traversed by using '/' characters in the path. For example, to put a reference to a Toolbar Button
         into 
         <i>the Panel which owns the Toolbar</i>:
      </p>
      <pre>
         <code>var myGrid = new Ext.grid.EditorGridPanel({
            title: 'My EditorGridPanel',
            store: myStore,
            colModel: myColModel,
            tbar: [{
            text: 'Save',
            handler: saveChanges,
            disabled: true,
            ref: '../saveButton'
            }],
            listeners: {
            afteredit: function() {
            //          The button reference is in the GridPanel
            myGrid.saveButton.enable();
            }
            }
            });
            
         </code>
      </pre>
      <p>In the code above, if the ref had been 
         <code>'saveButton'</code> the reference would have been placed into the Toolbar. Each '/' in the ref moves up one level from the Component's {@link
         #ownerCt}.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
  </xs:complexType>
  <xs:element name='component' type='ext:ext.Component'>
    <xs:annotation>
      <xs:documentation>

      <p>Base class for all Ext components. All subclasses of Component may participate in the automated Ext component lifecycle of
         creation, rendering and destruction which is provided by the {@link Ext.Container Container} class. Components may be added
         to a Container through the {@link Ext.Container#items items} config option at the time the Container is created, or they may
         be added dynamically via the {@link Ext.Container#add add} method.
      </p>
      <p>The Component base class has built-in support for basic hide/show and enable/disable behavior.</p>
      <p>All Components are registered with the {@link Ext.ComponentMgr} on construction so that they can be referenced at any time
         via {@link Ext#getCmp}, passing the {@link #id}.
      </p>
      <p>All user-developed visual widgets that are required to participate in automated lifecycle and size management should subclass
         Component (or {@link Ext.BoxComponent} if managed box model handling is required, ie height and width management).
      </p>
      <p>See the 
         <a href="http://extjs.com/learn/Tutorial:Creating_new_UI_controls">Creating new UI controls</a> tutorial for details on how and to either extend or augment ExtJs base classes to create custom Components.
      </p>
      <p>Every component has a specific xtype, which is its Ext-specific type name, along with methods for checking the xtype like
         {@link #getXType} and {@link #isXType}. This is the list of all valid xtypes:
      </p>
      <pre>xtype            Class
         -------------    ------------------
         box              {@link Ext.BoxComponent}
         button           {@link Ext.Button}
         buttongroup      {@link Ext.ButtonGroup}
         colorpalette     {@link Ext.ColorPalette}
         component        {@link Ext.Component}
         container        {@link Ext.Container}
         cycle            {@link Ext.CycleButton}
         dataview         {@link Ext.DataView}
         datepicker       {@link Ext.DatePicker}
         editor           {@link Ext.Editor}
         editorgrid       {@link Ext.grid.EditorGridPanel}
         flash            {@link Ext.FlashComponent}
         grid             {@link Ext.grid.GridPanel}
         listview         {@link Ext.ListView}
         panel            {@link Ext.Panel}
         progress         {@link Ext.ProgressBar}
         propertygrid     {@link Ext.grid.PropertyGrid}
         slider           {@link Ext.Slider}
         spacer           {@link Ext.Spacer}
         splitbutton      {@link Ext.SplitButton}
         tabpanel         {@link Ext.TabPanel}
         treepanel        {@link Ext.tree.TreePanel}
         viewport         {@link Ext.ViewPort}
         window           {@link Ext.Window}
         
         Toolbar components
         ---------------------------------------
         paging           {@link Ext.PagingToolbar}
         toolbar          {@link Ext.Toolbar}
         tbbutton         {@link Ext.Toolbar.Button}        (deprecated; use button)
         tbfill           {@link Ext.Toolbar.Fill}
         tbitem           {@link Ext.Toolbar.Item}
         tbseparator      {@link Ext.Toolbar.Separator}
         tbspacer         {@link Ext.Toolbar.Spacer}
         tbsplit          {@link Ext.Toolbar.SplitButton}   (deprecated; use splitbutton)
         tbtext           {@link Ext.Toolbar.TextItem}
         
         Menu components
         ---------------------------------------
         menu             {@link Ext.menu.Menu}
         colormenu        {@link Ext.menu.ColorMenu}
         datemenu         {@link Ext.menu.DateMenu}
         menubaseitem     {@link Ext.menu.BaseItem}
         menucheckitem    {@link Ext.menu.CheckItem}
         menuitem         {@link Ext.menu.Item}
         menuseparator    {@link Ext.menu.Separator}
         menutextitem     {@link Ext.menu.TextItem}
         
         Form components
         ---------------------------------------
         form             {@link Ext.FormPanel}
         checkbox         {@link Ext.form.Checkbox}
         checkboxgroup    {@link Ext.form.CheckboxGroup}
         combo            {@link Ext.form.ComboBox}
         datefield        {@link Ext.form.DateField}
         displayfield     {@link Ext.form.DisplayField}
         field            {@link Ext.form.Field}
         fieldset         {@link Ext.form.FieldSet}
         hidden           {@link Ext.form.Hidden}
         htmleditor       {@link Ext.form.HtmlEditor}
         label            {@link Ext.form.Label}
         numberfield      {@link Ext.form.NumberField}
         radio            {@link Ext.form.Radio}
         radiogroup       {@link Ext.form.RadioGroup}
         textarea         {@link Ext.form.TextArea}
         textfield        {@link Ext.form.TextField}
         timefield        {@link Ext.form.TimeField}
         trigger          {@link Ext.form.TriggerField}
         
         Chart components
         ---------------------------------------
         chart            {@link Ext.chart.Chart}
         barchart         {@link Ext.chart.BarChart}
         cartesianchart   {@link Ext.chart.CartesianChart}
         columnchart      {@link Ext.chart.ColumnChart}
         linechart        {@link Ext.chart.LineChart}
         piechart         {@link Ext.chart.PieChart}
         
         Store xtypes
         ---------------------------------------
         arraystore       {@link Ext.data.ArrayStore}
         directstore      {@link Ext.data.DirectStore}
         groupingstore    {@link Ext.data.GroupingStore}
         jsonstore        {@link Ext.data.JsonStore}
         simplestore      {@link Ext.data.SimpleStore}      (deprecated; use arraystore)
         store            {@link Ext.data.Store}
         xmlstore         {@link Ext.data.XmlStore}
         
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Container'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='layout' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    When creating complex UIs, it is important to remember that sizing and positioning of child items is the responsibility of
      the Container's layout manager. If you expect child items to be sized in response to user interactions, 
      <b>you must specify a layout manager</b> which creates and manages the type of layout you have in mind. For example:
      <pre>
         <code>new Ext.Window({
            width:300, height: 300,
            layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
            items: [{
            title: 'Panel inside a Window'
            }]
            }).show();
            
         </code>
      </pre>
      <p>Omitting the {@link #layout} config means that the {@link Ext.layout.ContainerLayout default layout manager} will be used
         which does nothing but render child components sequentially into the Container (no sizing or positioning will be performed
         in this situation).
      </p>
      <p>The layout manager class for this container may be specified as either as an Object or as a String:</p>
      <div>
         <ul class="mdetail-params">
            <li>
               <u>Specify as an Object</u>
            </li>
            <li style="list-style: none">
               <div>
                  <ul class="mdetail-params">
                     <li>Example usage:</li>
                     <li style="list-style: none">
                        <pre>
                           <code>layout: {
                              type: 'vbox',
                              padding: '5',
                              align: 'left'
                              }
                              
                           </code>
                        </pre>
                     </li>
                     <li>
                        <tt>
                           <b>type</b>
                        </tt>
                     </li>
                     <li style="list-style: none">
                        <br></br>
                        <p>The layout type to be used for this container. If not specified, a default {@link Ext.layout.ContainerLayout} will be created
                           and used.
                        </p>
                        <br></br>
                        <p>Valid layout 
                           <tt>type</tt> values are:
                        </p>
                        <div class="sub-desc">
                           <ul class="mdetail-params">
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.AbsoluteLayout absolute}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.AccordionLayout accordion}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.AnchorLayout anchor}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.ContainerLayout auto}</b>
                                 </tt>  
                                 <b>Default</b>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.BorderLayout border}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.CardLayout card}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.ColumnLayout column}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.FitLayout fit}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.FormLayout form}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.HBoxLayout hbox}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.MenuLayout menu}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.TableLayout table}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.ToolbarLayout toolbar}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.VBoxLayout vbox}</b>
                                 </tt>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li>Layout specific configuration properties</li>
                     <li style="list-style: none">
                        <br></br>
                        <p>Additional layout specific configuration properties may also be specified. For complete details regarding the valid config
                           options for each layout type, see the layout class corresponding to the 
                           <tt>type</tt> specified.
                        </p>
                     </li>
                  </ul>
               </div>
            </li>
            <li>
               <u>Specify as a String</u>
            </li>
            <li style="list-style: none">
               <div>
                  <ul class="mdetail-params">
                     <li>Example usage:</li>
                     <li style="list-style: none">
                        <pre>
                           <code>layout: 'vbox',
                              layoutConfig: {
                              padding: '5',
                              align: 'left'
                              }
                              
                           </code>
                        </pre>
                     </li>
                     <li>
                        <tt>
                           <b>layout</b>
                        </tt>
                     </li>
                     <li style="list-style: none">
                        <br></br>
                        <p>The layout 
                           <tt>type</tt> to be used for this container (see list of valid layout type values above).
                        </p>
                        <br></br>
                     </li>
                     <li>
                        <tt>
                           <b>{@link #layoutConfig}</b>
                        </tt>
                     </li>
                     <li style="list-style: none">
                        <br></br>
                        <p>Additional layout specific configuration properties. For complete details regarding the valid config options for each layout
                           type, see the layout class corresponding to the 
                           <tt>layout</tt> specified.
                        </p>
                     </li>
                  </ul>
               </div>
            </li>
         </ul>
      </div>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='layoutConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    This is a config object containing properties specific to the chosen 
      <b>
         <code>{@link #layout}</code>
      </b> if 
      <b>
         <code>{@link #layout}</code>
      </b> has been specified as a 
      <i>string</i>.
      <br></br>
      <br></br>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <pre>
         <b>** IMPORTANT</b>: be sure to specify a 
         <b>
            <code>{@link #layout}</code> ! **
         </b>
      </pre>
      <p>A single item, or an array of child Components to be added to this container, for example:</p>
      <pre>
         <code>// specifying a single item
            items: {...},
            layout: 'fit',    // specify a layout!
            
            // specifying multiple items
            items: [{...}, {...}],
            layout: 'anchor', // specify a layout!
            
         </code>
      </pre>
      <p>Each item may be:</p>
      <div>
         <ul class="mdetail-params">
            <li>any type of object based on {@link Ext.Component}</li>
            <li>a fully instanciated object or</li>
            <li>an object literal that:</li>
            <li style="list-style: none">
               <div>
                  <ul class="mdetail-params">
                     <li>has a specified 
                        <code>{@link Ext.Component#xtype xtype}</code>
                     </li>
                     <li>the {@link Ext.Component#xtype} specified is associated with the Component desired and should be chosen from one of the available
                        xtypes as listed in {@link Ext.Component}.
                     </li>
                     <li>If an 
                        <code>{@link Ext.Component#xtype xtype}</code> is not explicitly specified, the {@link #defaultType} for that Container is used.
                     </li>
                     <li>will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object</li>
                  </ul>
               </div>
            </li>
         </ul>
      </div>
      <p>
         <b>Notes</b>:
      </p>
      <div>
         <ul class="mdetail-params">
            <li>Ext uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
               when they are first shown (no sizing is done while hidden), or in response to a {@link #doLayout} call.
            </li>
            <li>Do not specify 
               <code>{@link Ext.Panel#contentEl contentEl}</code>/ 
               <code>{@link Ext.Panel#html html}</code> with 
               <code>items</code>.
            </li>
         </ul>
      </div>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaults' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A config object that will be applied to all components added to this container either via the {@link #items} config or via
         the {@link #add} or {@link #insert} methods. The 
         <tt>defaults</tt> config can contain any number of name/value property pairs to be added to each item, and should be valid for the types of
         items being added to the container. For example, to automatically apply padding to the body of each of a set of contained
         {@link Ext.Panel} items, you could pass: 
         <tt>defaults: {bodyStyle:'padding:15px'}</tt>.
      </p>
      <br></br>
      <p>
         <b>Note</b>: 
         <tt>defaults</tt> will not be applied to config objects if the option is already specified. For example:
      </p>
      <pre>
         <code>defaults: {               // defaults are applied to items, not the container
            autoScroll:true
            },
            items: [
            {
            xtype: 'panel',   // defaults 
            <b>do not</b> have precedence over
            id: 'panel1',     // options in config objects, so the defaults
            autoScroll: false // will not be applied here, panel1 will be autoScroll:false
            },
            new Ext.Panel({       // defaults 
            <b>do</b> have precedence over options
            id: 'panel2',     // options in components, so the defaults
            autoScroll: false // will be applied here, panel2 will be autoScroll:true.
            })
            ]
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='monitorResize'>
          <xs:annotation>
            <xs:documentation>
True to automatically monitor window resize events to handle anything that is sensitive to the current size of the viewport.
      This value is typically managed by the chosen 
      <code>{@link #layout}</code> and should not need to be set manually.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='layout'>
          <xs:annotation>
            <xs:documentation>
When creating complex UIs, it is important to remember that sizing and positioning of child items is the responsibility of
      the Container's layout manager. If you expect child items to be sized in response to user interactions, 
      <b>you must specify a layout manager</b> which creates and manages the type of layout you have in mind. For example:
      <pre>
         <code>new Ext.Window({
            width:300, height: 300,
            layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
            items: [{
            title: 'Panel inside a Window'
            }]
            }).show();
            
         </code>
      </pre>
      <p>Omitting the {@link #layout} config means that the {@link Ext.layout.ContainerLayout default layout manager} will be used
         which does nothing but render child components sequentially into the Container (no sizing or positioning will be performed
         in this situation).
      </p>
      <p>The layout manager class for this container may be specified as either as an Object or as a String:</p>
      <div>
         <ul class="mdetail-params">
            <li>
               <u>Specify as an Object</u>
            </li>
            <li style="list-style: none">
               <div>
                  <ul class="mdetail-params">
                     <li>Example usage:</li>
                     <li style="list-style: none">
                        <pre>
                           <code>layout: {
                              type: 'vbox',
                              padding: '5',
                              align: 'left'
                              }
                              
                           </code>
                        </pre>
                     </li>
                     <li>
                        <tt>
                           <b>type</b>
                        </tt>
                     </li>
                     <li style="list-style: none">
                        <br></br>
                        <p>The layout type to be used for this container. If not specified, a default {@link Ext.layout.ContainerLayout} will be created
                           and used.
                        </p>
                        <br></br>
                        <p>Valid layout 
                           <tt>type</tt> values are:
                        </p>
                        <div class="sub-desc">
                           <ul class="mdetail-params">
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.AbsoluteLayout absolute}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.AccordionLayout accordion}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.AnchorLayout anchor}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.ContainerLayout auto}</b>
                                 </tt>  
                                 <b>Default</b>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.BorderLayout border}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.CardLayout card}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.ColumnLayout column}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.FitLayout fit}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.FormLayout form}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.HBoxLayout hbox}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.MenuLayout menu}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.TableLayout table}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.ToolbarLayout toolbar}</b>
                                 </tt>
                              </li>
                              <li>
                                 <tt>
                                    <b>{@link Ext.layout.VBoxLayout vbox}</b>
                                 </tt>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li>Layout specific configuration properties</li>
                     <li style="list-style: none">
                        <br></br>
                        <p>Additional layout specific configuration properties may also be specified. For complete details regarding the valid config
                           options for each layout type, see the layout class corresponding to the 
                           <tt>type</tt> specified.
                        </p>
                     </li>
                  </ul>
               </div>
            </li>
            <li>
               <u>Specify as a String</u>
            </li>
            <li style="list-style: none">
               <div>
                  <ul class="mdetail-params">
                     <li>Example usage:</li>
                     <li style="list-style: none">
                        <pre>
                           <code>layout: 'vbox',
                              layoutConfig: {
                              padding: '5',
                              align: 'left'
                              }
                              
                           </code>
                        </pre>
                     </li>
                     <li>
                        <tt>
                           <b>layout</b>
                        </tt>
                     </li>
                     <li style="list-style: none">
                        <br></br>
                        <p>The layout 
                           <tt>type</tt> to be used for this container (see list of valid layout type values above).
                        </p>
                        <br></br>
                     </li>
                     <li>
                        <tt>
                           <b>{@link #layoutConfig}</b>
                        </tt>
                     </li>
                     <li style="list-style: none">
                        <br></br>
                        <p>Additional layout specific configuration properties. For complete details regarding the valid config options for each layout
                           type, see the layout class corresponding to the 
                           <tt>layout</tt> specified.
                        </p>
                     </li>
                  </ul>
               </div>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='layoutConfig'>
          <xs:annotation>
            <xs:documentation>
This is a config object containing properties specific to the chosen 
      <b>
         <code>{@link #layout}</code>
      </b> if 
      <b>
         <code>{@link #layout}</code>
      </b> has been specified as a 
      <i>string</i>.
      <br></br>
      <br></br>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bufferResize'>
          <xs:annotation>
            <xs:documentation>
When set to true (100 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the frequency
      it calculates and does a re-layout of components. This is useful for heavy containers or containers with a large quantity
      of sub-components for which frequent layout calls would be expensive.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeItem'>
          <xs:annotation>
            <xs:documentation>
A string component id or the numeric index of the component that should be initially activated within the container's layout
      on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's collection). activeItem
      only applies to layout styles that can display items one at a time (like {@link Ext.layout.AccordionLayout}, {@link Ext.layout.CardLayout}
      and {@link Ext.layout.FitLayout}). Related to {@link Ext.layout.ContainerLayout#activeItem}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>

      <pre>
         <b>** IMPORTANT</b>: be sure to specify a 
         <b>
            <code>{@link #layout}</code> ! **
         </b>
      </pre>
      <p>A single item, or an array of child Components to be added to this container, for example:</p>
      <pre>
         <code>// specifying a single item
            items: {...},
            layout: 'fit',    // specify a layout!
            
            // specifying multiple items
            items: [{...}, {...}],
            layout: 'anchor', // specify a layout!
            
         </code>
      </pre>
      <p>Each item may be:</p>
      <div>
         <ul class="mdetail-params">
            <li>any type of object based on {@link Ext.Component}</li>
            <li>a fully instanciated object or</li>
            <li>an object literal that:</li>
            <li style="list-style: none">
               <div>
                  <ul class="mdetail-params">
                     <li>has a specified 
                        <code>{@link Ext.Component#xtype xtype}</code>
                     </li>
                     <li>the {@link Ext.Component#xtype} specified is associated with the Component desired and should be chosen from one of the available
                        xtypes as listed in {@link Ext.Component}.
                     </li>
                     <li>If an 
                        <code>{@link Ext.Component#xtype xtype}</code> is not explicitly specified, the {@link #defaultType} for that Container is used.
                     </li>
                     <li>will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object</li>
                  </ul>
               </div>
            </li>
         </ul>
      </div>
      <p>
         <b>Notes</b>:
      </p>
      <div>
         <ul class="mdetail-params">
            <li>Ext uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
               when they are first shown (no sizing is done while hidden), or in response to a {@link #doLayout} call.
            </li>
            <li>Do not specify 
               <code>{@link Ext.Panel#contentEl contentEl}</code>/ 
               <code>{@link Ext.Panel#html html}</code> with 
               <code>items</code>.
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaults'>
          <xs:annotation>
            <xs:documentation>

      <p>A config object that will be applied to all components added to this container either via the {@link #items} config or via
         the {@link #add} or {@link #insert} methods. The 
         <tt>defaults</tt> config can contain any number of name/value property pairs to be added to each item, and should be valid for the types of
         items being added to the container. For example, to automatically apply padding to the body of each of a set of contained
         {@link Ext.Panel} items, you could pass: 
         <tt>defaults: {bodyStyle:'padding:15px'}</tt>.
      </p>
      <br></br>
      <p>
         <b>Note</b>: 
         <tt>defaults</tt> will not be applied to config objects if the option is already specified. For example:
      </p>
      <pre>
         <code>defaults: {               // defaults are applied to items, not the container
            autoScroll:true
            },
            items: [
            {
            xtype: 'panel',   // defaults 
            <b>do not</b> have precedence over
            id: 'panel1',     // options in config objects, so the defaults
            autoScroll: false // will not be applied here, panel1 will be autoScroll:false
            },
            new Ext.Panel({       // defaults 
            <b>do</b> have precedence over options
            id: 'panel2',     // options in components, so the defaults
            autoScroll: false // will be applied here, panel2 will be autoScroll:true.
            })
            ]
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoDestroy'>
          <xs:annotation>
            <xs:documentation>
If true the container will automatically destroy any contained component that is removed from it, else destruction must be
      handled manually (defaults to true).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceLayout'>
          <xs:annotation>
            <xs:documentation>
If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms to
      render in collapsed or hidden containers. (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideBorders'>
          <xs:annotation>
            <xs:documentation>
True to hide the borders of each contained component, false to defer to the component's existing border settings (defaults
      to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultType'>
          <xs:annotation>
            <xs:documentation>

      <p>The default {@link Ext.Component xtype} of child Components to create in this Container when a child item is specified as
         a raw configuration object, rather than as an instantiated Component.
      </p>
      <p>Defaults to 
         <tt>'panel'</tt>, except {@link Ext.menu.Menu} which defaults to 
         <tt>'menuitem'</tt>, and {@link Ext.Toolbar} and {@link Ext.ButtonGroup} which default to 
         <tt>'button'</tt>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='container' type='ext:ext.Container' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>

      <p>Base class for any {@link Ext.BoxComponent} that may contain other Components. Containers handle the basic behavior of containing
         items, namely adding, inserting and removing items.
      </p>
      <p>The most commonly used Container classes are {@link Ext.Panel}, {@link Ext.Window} and {@link Ext.TabPanel}. If you do not
         need the capabilities offered by the aforementioned classes you can create a lightweight Container to be encapsulated by an
         HTML element to your specifications by using the 
         <tt>
            <b>{@link Ext.Component#autoEl autoEl}</b>
         </tt> config option. This is a useful technique when creating embedded {@link Ext.layout.ColumnLayout column} layouts inside {@link
         Ext.form.FormPanel FormPanels} for example.
      </p>
      <p>The code below illustrates both how to explicitly create a Container, and how to implicitly create one using the 
         <b>
            <tt>'container'</tt>
         </b> xtype:
      </p>
      <pre>
         <code>// explicitly create a Container
            var embeddedColumns = new Ext.Container({
            autoEl: 'div',  // This is the default
            layout: 'column',
            defaults: {
            // implicitly create Container by specifying xtype
            xtype: 'container',
            autoEl: 'div', // This is the default.
            layout: 'form',
            columnWidth: 0.5,
            style: {
            padding: '10px'
            }
            },
            //  The two items below will be Ext.Containers, each encapsulated by a &lt;DIV&gt; element.
            items: [{
            items: {
            xtype: 'datefield',
            name: 'startDate',
            fieldLabel: 'Start date'
            }
            }, {
            items: {
            xtype: 'datefield',
            name: 'endDate',
            fieldLabel: 'End date'
            }
            }]
            });
         </code>
      </pre>
      <br></br>
      <br></br> 
      <p>
         <u>
            <b>Layout</b>
         </u>
      </p>
      <p>Container classes delegate the rendering of child Components to a layout manager class which must be configured into the Container
         using the 
         <code>
            <b>{@link #layout}</b>
         </code> configuration property.
      </p>
      <p>When either specifying child 
         <code>{@link #items}</code> of a Container, or dynamically {@link #add adding} Components to a Container, remember to consider how you wish the Container
         to arrange those child elements, and whether those child elements need to be sized using one of Ext's built-in 
         <b>
            <code>{@link #layout}</code>
         </b> schemes. By default, Containers use the {@link Ext.layout.ContainerLayout ContainerLayout} scheme which only renders child
         components, appending them one after the other inside the Container, and 
         <b>does not apply any sizing</b> at all.
      </p>
      <p>A common mistake is when a developer neglects to specify a 
         <b>
            <code>{@link #layout}</code>
         </b> (e.g. widgets like GridPanels or TreePanels are added to Containers for which no 
         <tt>
            <b>{@link #layout}</b>
         </tt> has been specified). If a Container is left to use the default {@link Ext.layout.ContainerLayout ContainerLayout} scheme,
         none of its child components will be resized, or changed in any way when the Container is resized.
      </p>
      <p>Certain layout managers allow dynamic addition of child components. Those that do include {@link Ext.layout.CardLayout}, {@link
         Ext.layout.AnchorLayout}, {@link Ext.layout.FormLayout}, and {@link Ext.layout.TableLayout}. For example:
      </p>
      <pre>
         <code>//  Create the GridPanel.
            var myNewGrid = new Ext.grid.GridPanel({
            store: myStore,
            columns: myColumnModel,
            title: 'Results', // the title becomes the title of the tab
            });
            
            myTabPanel.add(myNewGrid); // {@link Ext.TabPanel} implicitly uses {@link Ext.layout.CardLayout CardLayout}
            myTabPanel.{@link Ext.TabPanel#setActiveTab setActiveTab}(myNewGrid);
            
         </code>
      </pre>
      <br></br>
      <br></br> 
      <p>The example above adds a newly created GridPanel to a TabPanel. Note that a TabPanel uses {@link Ext.layout.CardLayout} as
         its layout manager which means all its child items are sized to {@link Ext.layout.FitLayout fit} exactly into its client area.
      </p>
      <p>
         <b>
            <u>Overnesting is a common problem</u>
         </b>. An example of overnesting occurs when a GridPanel is added to a TabPanel by wrapping the GridPanel 
         <i>inside</i> a wrapping Panel (that has no 
         <tt>
            <b>{@link #layout}</b>
         </tt> specified) and then add that wrapping Panel to the TabPanel. The point to realize is that a GridPanel 
         <b>is</b> a Component which can be added directly to a Container. If the wrapping Panel has no 
         <tt>
            <b>{@link #layout}</b>
         </tt> configuration, then the overnested GridPanel will not be sized as expected.
      </p>
      <p></p>
      <p>
         <u>
            <b>Adding via remote configuration</b>
         </u>
      </p>
      <p>A server side script can be used to add Components which are generated dynamically on the server. An example of adding a GridPanel
         to a TabPanel where the GridPanel is generated by the server based on certain parameters:
      </p>
      <pre>
         <code>// execute an Ajax request to invoke server side script:
            Ext.Ajax.request({
            url: 'gen-invoice-grid.php',
            // send additional parameters to instruct server script
            params: {
            startDate: Ext.getCmp('start-date').getValue(),
            endDate: Ext.getCmp('end-date').getValue()
            },
            // process the response object to add it to the TabPanel:
            success: function(xhr) {
            var newComponent = eval(xhr.responseText); // see discussion below
            myTabPanel.add(newComponent); // add the component to the TabPanel
            myTabPanel.setActiveTab(newComponent);
            },
            failure: function() {
            Ext.Msg.alert("Grid create failed", "Server communication failure");
            }
            });
            
         </code>
      </pre>
      <p>The server script needs to return an executable Javascript statement which, when processed using 
         <tt>eval()</tt>, will return either a config object with an {@link Ext.Component#xtype xtype}, or an instantiated Component. The server might
         return this for example:
      </p>
      <pre>
         <code>(function() {
            function formatDate(value){
            return value ? value.dateFormat('M d, Y') : '';
            };
            
            var store = new Ext.data.Store({
            url: 'get-invoice-data.php',
            baseParams: {
            startDate: '01/01/2008',
            endDate: '01/31/2008'
            },
            reader: new Ext.data.JsonReader({
            record: 'transaction',
            idProperty: 'id',
            totalRecords: 'total'
            }, [
            'customer',
            'invNo',
            {name: 'date', type: 'date', dateFormat: 'm/d/Y'},
            {name: 'value', type: 'float'}
            ])
            });
            
            var grid = new Ext.grid.GridPanel({
            title: 'Invoice Report',
            bbar: new Ext.PagingToolbar(store),
            store: store,
            columns: [
            {header: "Customer", width: 250, dataIndex: 'customer', sortable: true},
            {header: "Invoice Number", width: 120, dataIndex: 'invNo', sortable: true},
            {header: "Invoice Date", width: 100, dataIndex: 'date', renderer: formatDate, sortable: true},
            {header: "Value", width: 120, dataIndex: 'value', renderer: 'usMoney', sortable: true}
            ],
            });
            store.load();
            return grid;  // return instantiated component
            })();
            
         </code>
      </pre>
      <p>When the above code fragment is passed through the 
         <tt>eval</tt> function in the success handler of the Ajax request, the code is executed by the Javascript processor, and the anonymous
         function runs, and returns the instantiated grid component.
      </p>
      <p>Note: since the code above is 
         <i>generated</i> by a server script, the 
         <tt>baseParams</tt> for the Store, the metadata to allow generation of the Record layout, and the ColumnModel can all be generated into the code
         since these are all known on the server.
      </p>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.CycleButton'>
    <xs:complexContent>
      <xs:extension base='ext:ext.SplitButton'>
        <xs:sequence>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of {@link Ext.menu.CheckItem} 
      <b>config</b> objects to be used when creating the button's menu items (e.g., {text:'Foo', iconCls:'foo-icon'})
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='changeHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A callback function that will be invoked each time the active menu item in the button's menu has changed. If this callback
      is not supplied, the SplitButton will instead fire the {@link #change} event on active item change. The changeHandler function
      will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem item)
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>
An array of {@link Ext.menu.CheckItem} 
      <b>config</b> objects to be used when creating the button's menu items (e.g., {text:'Foo', iconCls:'foo-icon'})
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showText'>
          <xs:annotation>
            <xs:documentation>
True to display the active item's text as the button text (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prependText'>
          <xs:annotation>
            <xs:documentation>
A static string to prepend before the active item's text when displayed as the button's text (only applies when showText =
      true, defaults to '')
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='changeHandler'>
          <xs:annotation>
            <xs:documentation>
A callback function that will be invoked each time the active menu item in the button's menu has changed. If this callback
      is not supplied, the SplitButton will instead fire the {@link #change} event on active item change. The changeHandler function
      will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem item)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='forceIcon'>
          <xs:annotation>
            <xs:documentation>
A css class which sets an image to be used as the static icon for this button. This icon will always be displayed regardless
      of which item is selected in the dropdown list. This overrides the default behavior of changing the button's icon to match
      the selected item's icon on change.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='cycle' type='ext:ext.CycleButton' substitutionGroup='ext:splitbutton'>
    <xs:annotation>
      <xs:documentation>
A specialized SplitButton that contains a menu of {@link Ext.menu.CheckItem} elements. The button automatically cycles through
      each menu item on click, raising the button's {@link #change} event (or calling the button's {@link #changeHandler} function,
      if supplied) for the active menu item. Clicking on the arrow section of the button displays the dropdown menu just like a
      normal SplitButton. Example usage: 
      <pre>
         <code>var btn = new Ext.CycleButton({
            showText: true,
            prependText: 'View as ',
            items: [{
            text:'text only',
            iconCls:'view-text',
            checked:true
            },{
            text:'HTML',
            iconCls:'view-html'
            }],
            changeHandler:function(btn, item){
            Ext.Msg.alert('Change View', item.text);
            }
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.DataView'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='tpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The HTML fragment or an array of fragments that will make up the template used by this DataView. This should be specified
      in the same format expected by the constructor of {@link Ext.XTemplate}.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} to bind this DataView to.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
The HTML fragment or an array of fragments that will make up the template used by this DataView. This should be specified
      in the same format expected by the constructor of {@link Ext.XTemplate}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} to bind this DataView to.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemSelector'>
          <xs:annotation>
            <xs:documentation>

      <b>This is a required setting</b>. A simple CSS selector (e.g. 
      <tt>div.some-class</tt> or 
      <tt>span:first-child</tt>) that will be used to determine what nodes this DataView will be working with.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='multiSelect'>
          <xs:annotation>
            <xs:documentation>
True to allow selection of more than one item at a time, false to allow selection of only a single item at a time or no selection
      at all, depending on the value of {@link #singleSelect} (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='singleSelect'>
          <xs:annotation>
            <xs:documentation>
True to allow selection of exactly one item at a time, false to allow no selection at all (defaults to false). Note that if
      {@link #multiSelect} = true, this value will be ignored.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='simpleSelect'>
          <xs:annotation>
            <xs:documentation>
True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl, false to force
      the user to hold Ctrl or Shift to select more than on item (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overClass'>
          <xs:annotation>
            <xs:documentation>
A CSS class to apply to each item in the view on mouseover (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadingText'>
          <xs:annotation>
            <xs:documentation>
A string to display during data load operations (defaults to undefined). If specified, this text will be displayed in a loading
      div and the view's contents will be cleared while loading, otherwise the view's contents will continue to display normally
      until the new data is loaded and the contents are replaced.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selectedClass'>
          <xs:annotation>
            <xs:documentation>
A CSS class to apply to each selected item in the view (defaults to 'x-view-selected').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyText'>
          <xs:annotation>
            <xs:documentation>
The text to display in the view when there is no data to display (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferEmptyText'>
          <xs:annotation>
            <xs:documentation>
True to defer emptyText being applied until the store's first load
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackOver'>
          <xs:annotation>
            <xs:documentation>
True to enable mouseenter and mouseleave events
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='dataview' type='ext:ext.DataView' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
A mechanism for displaying data using custom layout templates and formatting. DataView uses an {@link Ext.XTemplate} as its
      internal templating mechanism, and is bound to an {@link Ext.data.Store} so that as the data in the store changes the view
      is automatically updated to reflect the changes. The view also provides built-in behavior for many common events that can
      occur for its contained items including click, doubleclick, mouseover, mouseout, etc. as well as a built-in selection model.
      
      <b>In order to use these features, an {@link #itemSelector} config must be provided for the DataView to determine what nodes
         it will be working with.
      </b> 
      <p>The example below binds a DataView to a {@link Ext.data.Store} and renders it into an {@link Ext.Panel}.</p>
      <pre>
         <code>var store = new Ext.data.JsonStore({
            url: 'get-images.php',
            root: 'images',
            fields: [
            'name', 'url',
            {name:'size', type: 'float'},
            {name:'lastmod', type:'date', dateFormat:'timestamp'}
            ]
            });
            store.load();
            
            var tpl = new Ext.XTemplate(
            '&lt;tpl for="."&gt;',
            '&lt;div class="thumb-wrap" id="{name}"&gt;',
            '&lt;div class="thumb"&gt;&lt;img src="{url}" title="{name}"&gt;&lt;/div&gt;',
            '&lt;span class="x-editable"&gt;{shortName}&lt;/span&gt;&lt;/div&gt;',
            '&lt;/tpl&gt;',
            '&lt;div class="x-clear"&gt;&lt;/div&gt;'
            );
            
            var panel = new Ext.Panel({
            id:'images-view',
            frame:true,
            width:535,
            autoHeight:true,
            collapsible:true,
            layout:'fit',
            title:'Simple DataView',
            
            items: new Ext.DataView({
            store: store,
            tpl: tpl,
            autoHeight:true,
            multiSelect: true,
            overClass:'x-view-over',
            itemSelector:'div.thumb-wrap',
            emptyText: 'No images to display'
            })
            });
            panel.render(document.body);
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.DatePicker'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='monthNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='dayNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDays' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday (defaults to null).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDatesRE' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    JavaScript regular expression used to disable a pattern of dates (defaults to null). The {@link #disabledDates} config will
      generate this regex internally, but if you specify disabledDatesRE it will take precedence over the disabledDates value.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDates' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so they are very
      powerful. Some examples: 
      <ul>
         <li>['03/08/2003', '09/16/2003'] would disable those exact dates</li>
         <li>['03/08', '09/16'] would disable those days for every year</li>
         <li>['^03/08'] would only match the beginning (useful if you are using short years)</li>
         <li>['03/../2006'] would disable every day in March 2006</li>
         <li>['^03'] would disable every day in every March</li>
      </ul>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support
      regular expressions, if you are using a date format that has '.' in it, you will have to escape the dot when restricting dates.
      For example: ['03\\.08\\.03'].
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='todayText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the button that selects the current date (defaults to 
      <tt>'Today'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='okText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the ok button (defaults to 
      <tt>'OK'</tt> to give the user extra clicking room)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cancelText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the cancel button (defaults to 
      <tt>'Cancel'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='todayTip'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display for the button that selects the current date (defaults to 
      <tt>'{current date} (Spacebar)'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the minDate validation fails (defaults to 
      <tt>'This date is before the minimum date'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the maxDate validation fails (defaults to 
      <tt>'This date is after the maximum date'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default date format string which can be overriden for localization support. The format must be valid according to {@link
      Date#parseDate} (defaults to 
      <tt>'m/d/y'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDaysText'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display when the date falls on a disabled day (defaults to 
      <tt>'Disabled'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesText'>
          <xs:annotation>
            <xs:documentation>
The tooltip text to display when the date falls on a disabled date (defaults to 
      <tt>'Disabled'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='monthNames'>
          <xs:annotation>
            <xs:documentation>
An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dayNames'>
          <xs:annotation>
            <xs:documentation>
An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nextText'>
          <xs:annotation>
            <xs:documentation>
The next month navigation button tooltip (defaults to 
      <tt>'Next Month (Control+Right)'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prevText'>
          <xs:annotation>
            <xs:documentation>
The previous month navigation button tooltip (defaults to 
      <tt>'Previous Month (Control+Left)'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='monthYearText'>
          <xs:annotation>
            <xs:documentation>
The header month selector tooltip (defaults to 
      <tt>'Choose a month (Control+Up/Down to move years)'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='startDay'>
          <xs:annotation>
            <xs:documentation>
Day index at which the week should begin, 0-based (defaults to 0, which is Sunday)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showToday'>
          <xs:annotation>
            <xs:documentation>
False to hide the footer area containing the Today button and disable the keyboard handler for spacebar that selects the current
      date (defaults to 
      <tt>true</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:date' name='minDate'>
          <xs:annotation>
            <xs:documentation>
Minimum allowable date (JavaScript date object, defaults to null)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:date' name='maxDate'>
          <xs:annotation>
            <xs:documentation>
Maximum allowable date (JavaScript date object, defaults to null)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDays'>
          <xs:annotation>
            <xs:documentation>
An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesRE'>
          <xs:annotation>
            <xs:documentation>
JavaScript regular expression used to disable a pattern of dates (defaults to null). The {@link #disabledDates} config will
      generate this regex internally, but if you specify disabledDatesRE it will take precedence over the disabledDates value.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDates'>
          <xs:annotation>
            <xs:documentation>
An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so they are very
      powerful. Some examples: 
      <ul>
         <li>['03/08/2003', '09/16/2003'] would disable those exact dates</li>
         <li>['03/08', '09/16'] would disable those days for every year</li>
         <li>['^03/08'] would only match the beginning (useful if you are using short years)</li>
         <li>['03/../2006'] would disable every day in March 2006</li>
         <li>['^03'] would disable every day in every March</li>
      </ul>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support
      regular expressions, if you are using a date format that has '.' in it, you will have to escape the dot when restricting dates.
      For example: ['03\\.08\\.03'].
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='datepicker' type='ext:ext.DatePicker' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
Simple date picker class.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Editor'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='field' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The Field object (or descendant) or config object for field
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='value' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The data value of the underlying field (defaults to "")
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='field'>
          <xs:annotation>
            <xs:documentation>
The Field object (or descendant) or config object for field
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlur'>
          <xs:annotation>
            <xs:documentation>
True to {@link #completeEdit complete the editing process} if in edit mode when the field is blurred. Defaults to 
      <tt>false</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoSize'>
          <xs:annotation>
            <xs:documentation>
True for the editor to automatically adopt the size of the element being edited, "width" to adopt the width only, or "height"
      to adopt the height only (defaults to false)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='revertInvalid'>
          <xs:annotation>
            <xs:documentation>
True to automatically revert the field value and cancel the edit when the user completes an edit and the field validation
      fails (defaults to true)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ignoreNoChange'>
          <xs:annotation>
            <xs:documentation>
True to skip the edit completion process (no save, no events fired) if the user completes an edit and the value has not changed
      (defaults to false). Applies only to string values - edits for other data types will never be ignored.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideEl'>
          <xs:annotation>
            <xs:documentation>
False to keep the bound element visible while the editor is displayed (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
The data value of the underlying field (defaults to "")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='alignment'>
          <xs:annotation>
            <xs:documentation>
The position to align to (see {@link Ext.Element#alignTo} for more details, defaults to "c-c?").
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
"sides" for sides/bottom only, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to "frame")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrain'>
          <xs:annotation>
            <xs:documentation>
True to constrain the editor to the viewport
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='swallowKeys'>
          <xs:annotation>
            <xs:documentation>
Handle the keydown/keypress events so they don't propagate (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='completeOnEnter'>
          <xs:annotation>
            <xs:documentation>
True to complete the edit when the enter key is pressed (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='cancelOnEsc'>
          <xs:annotation>
            <xs:documentation>
True to cancel the edit when the escape key is pressed (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='updateEl'>
          <xs:annotation>
            <xs:documentation>
True to update the innerHTML of the bound element when the update completes (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='editor' type='ext:ext.Editor' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
A base editor field that handles displaying/hiding on demand and has some built-in sizing and event handling logic.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Checkbox'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the {@link #checked} value changes (can be used instead of handling the check event). The handler is
      passed the following parameters: 
      <div class="mdetail-params">
         <ul>
            <li>
               <b>checkbox</b> : Ext.form.Checkbox
               <div class="sub-desc">The Checkbox being toggled.</div>
            </li>
            <li>
               <b>checked</b> : Boolean
               <div class="sub-desc">The new checked state of the checkbox.</div>
            </li>
         </ul>
      </div>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An object to use as the scope ('this' reference) of the {@link #handler} function (defaults to this Checkbox).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='checked'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> if the checkbox should render initially checked (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='boxLabel'>
          <xs:annotation>
            <xs:documentation>
The text that appears beside the checkbox
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='inputValue'>
          <xs:annotation>
            <xs:documentation>
The value that should go into the generated input element's value attribute
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
A function called when the {@link #checked} value changes (can be used instead of handling the check event). The handler is
      passed the following parameters: 
      <div class="mdetail-params">
         <ul>
            <li>
               <b>checkbox</b> : Ext.form.Checkbox
               <div class="sub-desc">The Checkbox being toggled.</div>
            </li>
            <li>
               <b>checked</b> : Boolean
               <div class="sub-desc">The new checked state of the checkbox.</div>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
An object to use as the scope ('this' reference) of the {@link #handler} function (defaults to this Checkbox).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='checkbox' type='ext:ext.form.Checkbox' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
Single checkbox field. Can be used as a direct replacement for traditional checkbox fields.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.CheckboxGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An Array of {@link Ext.form.Checkbox Checkbox}es or Checkbox config objects to arrange in the group.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout. This config
      can take several types of values: 
      <ul>
         <li>
            <b>'auto'</b> : 
            <p class="sub-desc">The controls will be rendered one per column on one row and the width of each column will be evenly distributed based on the
               width of the overall field container. This is the default.
            </p>
         </li>
         <li>
            <b>Number</b> : 
            <p class="sub-desc">If you specific a number (e.g., 3) that number of columns will be created and the contained controls will be automatically
               distributed based on the value of {@link #vertical}.
            </p>
         </li>
         <li>
            <b>Array</b> : Object
            <p class="sub-desc">You can also specify an array of column widths, mixing integer (fixed width) and float (percentage width) values as needed
               (e.g., [100, .25, .75]). Any integer values will be rendered first, then any float values will be calculated as a percentage
               of the remaining space. Float values do not have to add up to 1 (100%) although if you want the controls to take up the entire
               field container you should do so.
            </p>
         </li>
      </ul>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>
An Array of {@link Ext.form.Checkbox Checkbox}es or Checkbox config objects to arrange in the group.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout. This config
      can take several types of values: 
      <ul>
         <li>
            <b>'auto'</b> : 
            <p class="sub-desc">The controls will be rendered one per column on one row and the width of each column will be evenly distributed based on the
               width of the overall field container. This is the default.
            </p>
         </li>
         <li>
            <b>Number</b> : 
            <p class="sub-desc">If you specific a number (e.g., 3) that number of columns will be created and the contained controls will be automatically
               distributed based on the value of {@link #vertical}.
            </p>
         </li>
         <li>
            <b>Array</b> : Object
            <p class="sub-desc">You can also specify an array of column widths, mixing integer (fixed width) and float (percentage width) values as needed
               (e.g., [100, .25, .75]). Any integer values will be rendered first, then any float values will be calculated as a percentage
               of the remaining space. Float values do not have to add up to 1 (100%) although if you want the controls to take up the entire
               field container you should do so.
            </p>
         </li>
      </ul>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='vertical'>
          <xs:annotation>
            <xs:documentation>
True to distribute contained controls across columns, completely filling each column top to bottom before starting on the
      next column. The number of controls in each column will be automatically calculated to keep columns as even as possible. The
      default value is false, so that controls will be added to columns one at a time, completely filling each row left to right
      before starting on the next row.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlank'>
          <xs:annotation>
            <xs:documentation>
False to validate that at least one item in the group is checked (defaults to true). If no items are selected at validation
      time, {@link @blankText} will be used as the error text.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='blankText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the {@link #allowBlank} validation fails (defaults to "You must select at least one item in this
      group")
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='checkboxgroup' type='ext:ext.form.CheckboxGroup' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>

      <p>A grouping container for {@link Ext.form.Checkbox} controls.</p>
      <p>Sample usage:</p>
      <pre>
         <code>var myCheckboxGroup = new Ext.form.CheckboxGroup({
            id:'myGroup',
            xtype: 'checkboxgroup',
            fieldLabel: 'Single Column',
            itemCls: 'x-check-group-alt',
            // Put all controls in a single column with width 100%
            columns: 1,
            items: [
            {boxLabel: 'Item 1', name: 'cb-col-1'},
            {boxLabel: 'Item 2', name: 'cb-col-2', checked: true},
            {boxLabel: 'Item 3', name: 'cb-col-3'}
            ]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.ComboBox'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TriggerField'>
        <xs:sequence>
            <xs:element name='transform' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox. Note that if you specify this and the combo
      is going to be in an {@link Ext.form.BasicForm} or {@link Ext.form.FormPanel}, you must also set 
      <tt>{@link #lazyRender} = true</tt>.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The data source to which this combo is bound (defaults to 
      <tt>undefined</tt>). Acceptable values for this property are: 
      <div class="mdetail-params">
         <ul>
            <li>
               <b>any {@link Ext.data.Store Store} subclass</b>
            </li>
            <li>
               <b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally. 
               <div class="mdetail-params">
                  <ul>
                     <li>
                        <b>1-dimensional array</b> : (e.g., 
                        <tt>['Foo','Bar']</tt>)
                        <div class="sub-desc">A 1-dimensional array will automatically be expanded (each array item will be the combo {@link #valueField value} and {@link
                           #displayField text})
                        </div>
                     </li>
                     <li>
                        <b>2-dimensional array</b> : (e.g., 
                        <tt>[['f','Foo'],['b','Bar']]</tt>)
                        <div class="sub-desc">For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo {@link #valueField value},
                           while the value at index 1 is assumed to be the combo {@link #displayField text}.
                        </div>
                     </li>
                  </ul>
               </div>
            </li>
         </ul>
      </div>
      <p>See also 
         <tt>{@link #mode}</tt>.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='tpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>The template string, or {@link Ext.XTemplate} instance to use to display each item in the dropdown list. The dropdown list
         is displayed in a DataView. See {@link #view}.
      </p>
      <p>The default template string is:</p>
      <pre>
         <code>'&lt;tpl for="."&gt;&lt;div class="x-combo-list-item"&gt;{' + this.displayField + '}&lt;/div&gt;&lt;/tpl&gt;'
            
         </code>
      </pre>
      <p>Override the default value to create custom UI layouts for items in the list. For example:</p>
      <pre>
         <code>'&lt;tpl for="."&gt;&lt;div ext:qtip="{state}. {nick}" class="x-combo-list-item"&gt;{state}&lt;/div&gt;&lt;/tpl&gt;'
            
         </code>
      </pre>
      <p>The template 
         <b>must</b> contain one or more substitution parameters using field names from the Combo's {@link #store Store}. In the example above an
      </p>
      <pre>ext:qtip</pre>attribute is added to display other fields from the Store.
      <br></br>
      <br></br> 
      <p>To preserve the default visual look of list items, add the CSS class name</p>
      <pre>x-combo-list-item</pre>to the template's container element.
      <br></br>
      <br></br> 
      <p>Also see {@link #itemSelector} for additional details.</p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='transform'>
          <xs:annotation>
            <xs:documentation>
The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox. Note that if you specify this and the combo
      is going to be in an {@link Ext.form.BasicForm} or {@link Ext.form.FormPanel}, you must also set 
      <tt>{@link #lazyRender} = true</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lazyRender'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to prevent the ComboBox from rendering until requested (should always be used when rendering into an {@link Ext.Editor} (e.g.
      {@link Ext.grid.EditorGridPanel Grids}), defaults to 
      <tt>false</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The data source to which this combo is bound (defaults to 
      <tt>undefined</tt>). Acceptable values for this property are: 
      <div class="mdetail-params">
         <ul>
            <li>
               <b>any {@link Ext.data.Store Store} subclass</b>
            </li>
            <li>
               <b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally. 
               <div class="mdetail-params">
                  <ul>
                     <li>
                        <b>1-dimensional array</b> : (e.g., 
                        <tt>['Foo','Bar']</tt>)
                        <div class="sub-desc">A 1-dimensional array will automatically be expanded (each array item will be the combo {@link #valueField value} and {@link
                           #displayField text})
                        </div>
                     </li>
                     <li>
                        <b>2-dimensional array</b> : (e.g., 
                        <tt>[['f','Foo'],['b','Bar']]</tt>)
                        <div class="sub-desc">For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo {@link #valueField value},
                           while the value at index 1 is assumed to be the combo {@link #displayField text}.
                        </div>
                     </li>
                  </ul>
               </div>
            </li>
         </ul>
      </div>
      <p>See also 
         <tt>{@link #mode}</tt>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='title'>
          <xs:annotation>
            <xs:documentation>
If supplied, a header element is created containing this text and added into the top of the dropdown list (defaults to undefined,
      with no header element)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='listWidth'>
          <xs:annotation>
            <xs:documentation>
The width (used as a parameter to {@link Ext.Element#setWidth}) of the dropdown list (defaults to the width of the ComboBox
      field). See also 
      <tt>{@link #minListWidth}</tt>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='displayField'>
          <xs:annotation>
            <xs:documentation>
The underlying {@link Ext.data.Field#name data field name} to bind to this ComboBox (defaults to undefined if 
      <tt>{@link #mode} = 'remote'</tt> or 
      <tt>'text'</tt> if {@link #transform transforming a select} a select). 
      <p>See also 
         <tt>{@link #valueField}</tt>.
      </p>
      <p>
         <b>Note</b>: if using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a {@link Ext.grid.Column#renderer renderer} will
         be needed to show the displayField when the editor is not active.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='valueField'>
          <xs:annotation>
            <xs:documentation>
The underlying {@link Ext.data.Field#name data value name} to bind to this ComboBox (defaults to undefined if 
      <tt>{@link #mode} = 'remote'</tt> or 
      <tt>'value'</tt> if {@link #transform transforming a select}). 
      <p>
         <b>Note</b>: use of a 
         <tt>valueField</tt> requires the user to make a selection in order for a value to be mapped. See also 
         <tt>{@link #hiddenName}</tt>, 
         <tt>{@link #hiddenValue}</tt>, and 
         <tt>{@link #displayField}</tt>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenName'>
          <xs:annotation>
            <xs:documentation>
If specified, a hidden form field with this name is dynamically generated to store the field's data value (defaults to the
      underlying DOM element's name). Required for the combo's value to automatically post during a form submission. See also {@link
      #valueField}. 
      <p>
         <b>Note</b>: the hidden field's id will also default to this name if {@link #hiddenId} is not specified. The ComboBox {@link Ext.Component#id
         id} and the 
         <tt>{@link #hiddenId}</tt> 
         <b>should be different</b>, since no two DOM nodes should share the same id. So, if the ComboBox 
         <tt>{@link Ext.form.Field#name name}</tt> and 
         <tt>hiddenName</tt> are the same, you should specify a unique 
         <tt>{@link #hiddenId}</tt>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenId'>
          <xs:annotation>
            <xs:documentation>
If 
      <tt>{@link #hiddenName}</tt> is specified, 
      <tt>hiddenId</tt> can also be provided to give the hidden field a unique id (defaults to the 
      <tt>{@link #hiddenName}</tt>). The 
      <tt>hiddenId</tt> and combo {@link Ext.Component#id id} should be different, since no two DOM nodes should share the same id.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenValue'>
          <xs:annotation>
            <xs:documentation>
Sets the initial value of the hidden field if {@link #hiddenName} is specified to contain the selected {@link #valueField},
      from the Store. Defaults to the configured 
      <tt>{@link Ext.form.Field#value value}</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to add to the predefined 
      <tt>'x-combo-list'</tt> class applied the dropdown list element (defaults to '').
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selectedClass'>
          <xs:annotation>
            <xs:documentation>
CSS class to apply to the selected item in the dropdown list (defaults to 
      <tt>'x-combo-selected'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listEmptyText'>
          <xs:annotation>
            <xs:documentation>
The empty text to display in the data view if no items are found. (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> or 
      <tt>"sides"</tt> for the default effect, 
      <tt>"frame"</tt> for 4-way shadow, and 
      <tt>"drop"</tt> for bottom-right
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listAlign'>
          <xs:annotation>
            <xs:documentation>
A valid anchor position value. See 
      <tt>{@link Ext.Element#alignTo}</tt> for details on supported anchor positions (defaults to 
      <tt>'tl-bl?'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
The maximum height in pixels of the dropdown list before scrollbars are shown (defaults to 
      <tt>300</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minHeight'>
          <xs:annotation>
            <xs:documentation>
The minimum height in pixels of the dropdown list when the list is constrained by its distance to the viewport edges (defaults
      to 
      <tt>90</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='triggerAction'>
          <xs:annotation>
            <xs:documentation>
The action to execute when the trigger is clicked. 
      <div class="mdetail-params">
         <ul>
            <li>
               <b>
                  <tt>'query'</tt>
               </b> : 
               <b>Default</b> 
               <p class="sub-desc">{@link #doQuery run the query} using the {@link Ext.form.Field#getRawValue raw value}.</p>
            </li>
            <li>
               <b>
                  <tt>'all'</tt>
               </b> : 
               <p class="sub-desc">{@link #doQuery run the query} specified by the 
                  <tt>{@link #allQuery}</tt> config option
               </p>
            </li>
         </ul>
      </div>
      <p>See also 
         <code>{@link #queryParam}</code>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minChars'>
          <xs:annotation>
            <xs:documentation>
The minimum number of characters the user must type before autocomplete and {@link #typeAhead} activate (defaults to 
      <tt>4</tt> if 
      <tt>{@link #mode} = 'remote'</tt> or 
      <tt>0</tt> if 
      <tt>{@link #mode} = 'local'</tt>, does not apply if 
      <tt>{@link Ext.form.TriggerField#editable editable} = false</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='typeAhead'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to populate and autoselect the remainder of the text being typed after a configurable delay ({@link #typeAheadDelay}) if
      it matches a known value (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='queryDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds to delay between the start of typing and sending the query to filter the dropdown list
      (defaults to 
      <tt>500</tt> if 
      <tt>{@link #mode} = 'remote'</tt> or 
      <tt>10</tt> if 
      <tt>{@link #mode} = 'local'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageSize'>
          <xs:annotation>
            <xs:documentation>
If greater than 
      <tt>0</tt>, a {@link Ext.PagingToolbar} is displayed in the footer of the dropdown list and the {@link #doQuery filter queries} will
      execute with page start and {@link Ext.PagingToolbar#pageSize limit} parameters. Only applies when 
      <tt>{@link #mode} = 'remote'</tt> (defaults to 
      <tt>0</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='queryParam'>
          <xs:annotation>
            <xs:documentation>
Name of the query ({@link Ext.data.Store#baseParam baseParam} name for the store) as it will be passed on the querystring
      (defaults to 
      <tt>'query'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadingText'>
          <xs:annotation>
            <xs:documentation>
The text to display in the dropdown list while data is loading. Only applies when 
      <tt>{@link #mode} = 'remote'</tt> (defaults to 
      <tt>'Loading...'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizable'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to add a resize handle to the bottom of the dropdown list (creates an {@link Ext.Resizable} with 'se' {@link Ext.Resizable#pinned
      pinned} handles). Defaults to 
      <tt>false</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='handleHeight'>
          <xs:annotation>
            <xs:documentation>
The height in pixels of the dropdown list resize handle if 
      <tt>{@link #resizable} = true</tt> (defaults to 
      <tt>8</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='allQuery'>
          <xs:annotation>
            <xs:documentation>
The text query to send to the server to return all records for the list with no filtering (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='mode'>
          <xs:annotation>
            <xs:documentation>
Acceptable values are: 
      <div class="mdetail-params">
         <ul>
            <li>
               <b>
                  <tt>'remote'</tt>
               </b> : 
               <b>Default</b> 
               <p class="sub-desc">Automatically loads the 
                  <tt>{@link #store}</tt> the 
                  <b>first</b> time the trigger is clicked. If you do not want the store to be automatically loaded the first time the trigger is clicked,
                  set to 
                  <tt>'local'</tt> and manually load the store. To force a requery of the store 
                  <b>every</b> time the trigger is clicked see 
                  <tt>{@link #lastQuery}</tt>.
               </p>
            </li>
            <li>
               <b>
                  <tt>'local'</tt>
               </b> : 
               <p class="sub-desc">ComboBox loads local data</p>
               <pre>
                  <code>var combo = new Ext.form.ComboBox({
                     renderTo: document.body,
                     mode: 'local',
                     store: new Ext.data.ArrayStore({
                     id: 0,
                     fields: [
                     'myId',  // numeric value is the key
                     'displayText'
                     ],
                     data: [[1, 'item1'], [2, 'item2']]  // data is local
                     }),
                     valueField: 'myId',
                     displayField: 'displayText',
                     triggerAction: 'all'
                     });
                     
                  </code>
               </pre>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minListWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width of the dropdown list in pixels (defaults to 
      <tt>70</tt>, will be ignored if 
      <tt>{@link #listWidth}</tt> has a higher value)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceSelection'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to restrict the selected value to one of the values in the list, 
      <tt>false</tt> to allow the user to set arbitrary text into the field (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='typeAheadDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds to wait until the typeahead text is displayed if 
      <tt>{@link #typeAhead} = true</tt> (defaults to 
      <tt>250</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='valueNotFoundText'>
          <xs:annotation>
            <xs:documentation>
When using a name/value combo, if the value passed to setValue is not found in the store, valueNotFoundText will be displayed
      as the field text if defined (defaults to undefined). If this default text is used, it means there is no value set and no
      validation will occur on this field.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lazyInit'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to not initialize the list for this combo until the field is focused (defaults to 
      <tt>true</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>

      <p>The template string, or {@link Ext.XTemplate} instance to use to display each item in the dropdown list. The dropdown list
         is displayed in a DataView. See {@link #view}.
      </p>
      <p>The default template string is:</p>
      <pre>
         <code>'&lt;tpl for="."&gt;&lt;div class="x-combo-list-item"&gt;{' + this.displayField + '}&lt;/div&gt;&lt;/tpl&gt;'
            
         </code>
      </pre>
      <p>Override the default value to create custom UI layouts for items in the list. For example:</p>
      <pre>
         <code>'&lt;tpl for="."&gt;&lt;div ext:qtip="{state}. {nick}" class="x-combo-list-item"&gt;{state}&lt;/div&gt;&lt;/tpl&gt;'
            
         </code>
      </pre>
      <p>The template 
         <b>must</b> contain one or more substitution parameters using field names from the Combo's {@link #store Store}. In the example above an
      </p>
      <pre>ext:qtip</pre>attribute is added to display other fields from the Store.
      <br></br>
      <br></br> 
      <p>To preserve the default visual look of list items, add the CSS class name</p>
      <pre>x-combo-list-item</pre>to the template's container element.
      <br></br>
      <br></br> 
      <p>Also see {@link #itemSelector} for additional details.</p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemSelector'>
          <xs:annotation>
            <xs:documentation>

      <p>A simple CSS selector (e.g. div.some-class or span:first-child) that will be used to determine what nodes the {@link #view
         Ext.DataView} which handles the dropdown display will be working with.
      </p>
      <p>
         <b>Note</b>: this setting is 
         <b>required</b> if a custom XTemplate has been specified in {@link #tpl} which assigns a class other than
      </p>
      <pre>'x-combo-list-item'</pre>to dropdown list items
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='combo' type='ext:ext.form.ComboBox' substitutionGroup='ext:trigger'>
    <xs:annotation>
      <xs:documentation>

      <p>A combobox control with support for autocomplete, remote-loading, paging and many other features.</p>
      <p>A ComboBox works in a similar manner to a traditional HTML &lt;select&gt; field. The difference is that to submit the {@link #valueField},
         you must specify a {@link #hiddenName} to create a hidden input field to hold the value of the valueField. The 
         <i>{@link #displayField}</i> is shown in the text field which is named according to the {@link #name}.
      </p>
      <p style="font-weight: bold">
         <u>Events</u>
      </p>
      <p>To do something when something in ComboBox is selected, configure the select event:</p>
      <pre>
         <code>var cb = new Ext.form.ComboBox({
            // all of your config options
            listeners:{
            scope: yourScope,
            'select': yourFunction
            }
            });
            
            // Alternatively, you can assign events after the object is created:
            var cb = new Ext.form.ComboBox(yourOptions);
            cb.on('select', yourFunction, yourScope);
            
         </code>
      </pre>
      <br></br>
      <br></br> 
      <p style="font-weight: bold">
         <u>ComboBox in Grid</u>
      </p>
      <p>If using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a {@link Ext.grid.Column#renderer renderer} will be
         needed to show the displayField when the editor is not active. Set up the renderer manually, or implement a reusable render,
         for example:
      </p>
      <pre>
         <code>// create reusable renderer
            Ext.util.Format.comboRenderer = function(combo){
            return function(value){
            var record = combo.findRecord(combo.{@link #valueField}, value);
            return record ? record.get(combo.{@link #displayField}) : combo.{@link #valueNotFoundText};
            }
            }
            
            // create the combo instance
            var combo = new Ext.form.ComboBox({
            {@link #typeAhead}: true,
            {@link #triggerAction}: 'all',
            {@link #lazyRender}:true,
            {@link #mode}: 'local',
            {@link #store}: new Ext.data.ArrayStore({
            id: 0,
            fields: [
            'myId',
            'displayText'
            ],
            data: [[1, 'item1'], [2, 'item2']]
            }),
            {@link #valueField}: 'myId',
            {@link #displayField}: 'displayText'
            });
            
            // snippet of column model used within grid
            var cm = new Ext.grid.ColumnModel([{
            ...
            },{
            header: "Some Header",
            dataIndex: 'whatever',
            width: 130,
            editor: combo, // specify reference to combo instance
            renderer: Ext.util.Format.comboRenderer(combo) // pass combo instance to reusable renderer
            },
            ...
            ]);
            
         </code>
      </pre>
      <br></br>
      <br></br> 
      <p style="font-weight: bold">
         <u>Filtering</u>
      </p>
      <p>A ComboBox {@link #doQuery uses filtering itself}, for information about filtering the ComboBox store manually see 
         <tt>{@link #lastQuery}</tt>.
      </p>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.DateField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TriggerField'>
        <xs:sequence>
            <xs:element name='disabledDays' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of days to disable, 0 based (defaults to null). Some examples:
      <pre>
         <code>// disable Sunday and Saturday:
            disabledDays:  [0, 6]
            // disable weekdays:
            disabledDays: [1,2,3,4,5]
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDates' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so they are very
      powerful. Some examples:
      <pre>
         <code>// disable these exact dates:
            disabledDates: ["03/08/2003", "09/16/2003"]
            // disable these days for every year:
            disabledDates: ["03/08", "09/16"]
            // only match the beginning (useful if you are using short years):
            disabledDates: ["^03/08"]
            // disable every day in March 2006:
            disabledDates: ["03/../2006"]
            // disable every day in every March:
            disabledDates: ["^03"]
            
         </code>
      </pre>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support
      regular expressions, if you are using a {@link #format date format} that has "." in it, you will have to escape the dot when
      restricting dates. For example: 
      <tt>["03\\.08\\.03"]</tt>.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default date format string which can be overriden for localization support. The format must be valid according to {@link
      Date#parseDate} (defaults to 
      <tt>'m/d/Y'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='altFormats'>
          <xs:annotation>
            <xs:documentation>
Multiple date formats separated by "
      <tt>|</tt>" to try when parsing a user input value and it does not match the defined format (defaults to 
      <tt>'m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDaysText'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display when the date falls on a disabled day (defaults to 
      <tt>'Disabled'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesText'>
          <xs:annotation>
            <xs:documentation>
The tooltip text to display when the date falls on a disabled date (defaults to 
      <tt>'Disabled'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is before 
      <tt>{@link #minValue}</tt> (defaults to 
      <tt>'The date in this field must be after {minValue}'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is after 
      <tt>{@link #maxValue}</tt> (defaults to 
      <tt>'The date in this field must be before {maxValue}'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showToday'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to hide the footer area of the DatePicker containing the Today button and disable the keyboard handler for spacebar that
      selects the current date (defaults to 
      <tt>true</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed date. Can be either a Javascript date object or a string date in a valid format (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed date. Can be either a Javascript date object or a string date in a valid format (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDays'>
          <xs:annotation>
            <xs:documentation>
An array of days to disable, 0 based (defaults to null). Some examples:
      <pre>
         <code>// disable Sunday and Saturday:
            disabledDays:  [0, 6]
            // disable weekdays:
            disabledDays: [1,2,3,4,5]
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDates'>
          <xs:annotation>
            <xs:documentation>
An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so they are very
      powerful. Some examples:
      <pre>
         <code>// disable these exact dates:
            disabledDates: ["03/08/2003", "09/16/2003"]
            // disable these days for every year:
            disabledDates: ["03/08", "09/16"]
            // only match the beginning (useful if you are using short years):
            disabledDates: ["^03/08"]
            // disable every day in March 2006:
            disabledDates: ["03/../2006"]
            // disable every day in every March:
            disabledDates: ["^03"]
            
         </code>
      </pre>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support
      regular expressions, if you are using a {@link #format date format} that has "." in it, you will have to escape the dot when
      restricting dates. For example: 
      <tt>["03\\.08\\.03"]</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='datefield' type='ext:ext.form.DateField' substitutionGroup='ext:trigger'>
    <xs:annotation>
      <xs:documentation>
Provides a date input field with a {@link Ext.DatePicker} dropdown and automatic date validation.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.DisplayField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='htmlEncode'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to skip HTML-encoding the text when rendering it (defaults to 
      <tt>false</tt>). This might be useful if you want to include tags in the field's innerHTML rather than rendering them as string literals
      per the default logic.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='displayfield' type='ext:ext.form.DisplayField' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
A display-only text field which is not validated and not submitted.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Field'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='value' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A value to initialize this field with (defaults to undefined).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoCreate' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.DomHelper DomHelper} element spec, or true for a default element spec. Used to create the {@link Ext.Component#getEl
         Element} which will encapsulate this Component. See 
         <tt>{@link Ext.Component#autoEl autoEl}</tt> for details. Defaults to:
      </p>
      <pre>
         <code>{tag: "input", type: "text", size: "20", autocomplete: "off"}</code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='inputType'>
          <xs:annotation>
            <xs:documentation>
The type attribute for input fields -- e.g. radio, text, password, file (defaults to "text"). The types "file" and "password"
      must be used to render those field types currently -- there are no separate Ext components for those. Note that if you use
      
      <tt>inputType:'file'</tt>, {@link #emptyText} is not supported and should be avoided.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabIndex'>
          <xs:annotation>
            <xs:documentation>
The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo (defaults
      to undefined).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
A value to initialize this field with (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='name'>
          <xs:annotation>
            <xs:documentation>
The field's HTML name attribute (defaults to ""). 
      <b>Note</b>: this property must be set if this field is to be automatically included with {@link Ext.form.BasicForm#submit form submit()}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='invalidClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when marking a field invalid (defaults to "x-form-invalid")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='invalidText'>
          <xs:annotation>
            <xs:documentation>
The error text to use when marking a field invalid and no message is provided (defaults to "The value in this field is invalid")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='focusClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when the field receives focus (defaults to "x-form-focus")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='validationEvent'>
          <xs:annotation>
            <xs:documentation>
The event that should initiate field validation. Set to false to disable automatic validation (defaults to "keyup").
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='validateOnBlur'>
          <xs:annotation>
            <xs:documentation>
Whether the field should validate when it loses focus (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='validationDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoCreate'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.DomHelper DomHelper} element spec, or true for a default element spec. Used to create the {@link Ext.Component#getEl
         Element} which will encapsulate this Component. See 
         <tt>{@link Ext.Component#autoEl autoEl}</tt> for details. Defaults to:
      </p>
      <pre>
         <code>{tag: "input", type: "text", size: "20", autocomplete: "off"}</code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fieldClass'>
          <xs:annotation>
            <xs:documentation>
The default CSS class for the field (defaults to "x-form-field")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='msgTarget'>
          <xs:annotation>
            <xs:documentation>
The location where error text should display. Should be one of the following values (defaults to 'qtip'): 
      <pre>Value         Description
         -----------   ----------------------------------------------------------------------
         qtip          Display a quick tip when the user hovers over the field
         title         Display a default browser title attribute popup
         under         Add a block div beneath the field containing the error text
         side          Add an error icon to the right of the field with a popup on hover
         [element id]  Add the error text directly to the innerHTML of the specified element
         
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='msgFx'>
          <xs:annotation>
            <xs:documentation>

      <b>Experimental</b> The effect used when displaying a validation message under the field (defaults to 'normal').
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='readOnly'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to mark the field as readOnly in HTML (defaults to 
      <tt>false</tt>). 
      <br></br>
      <p>
         <b>Note</b>: this only sets the element's readOnly DOM attribute. Setting 
         <code>readOnly=true</code>, for example, will not disable triggering a ComboBox or DateField; it gives you the option of forcing the user to choose
         via the trigger without typing in the text box. To hide the trigger use 
         <code>{@link Ext.form.TriggerField#hideTrigger hideTrigger}</code>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='field' type='ext:ext.form.Field' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Base class for form fields that provides default event handling, sizing, value handling and other functionality.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.FieldSet'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='checkboxToggle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <tt>true</tt> to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the fieldset when the checkbox
      is toggled. (defaults to 
      <tt>false</tt>). 
      <p>A {@link Ext.DomHelper DomHelper} element spec may also be specified to create the checkbox. If 
         <tt>true</tt> is specified, the default DomHelper config object used to create the element is:
      </p>
      <pre>
         <code>{tag: 'input', type: 'checkbox', name: this.checkboxName || this.id+'-checkbox'}
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='checkboxToggle'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the fieldset when the checkbox
      is toggled. (defaults to 
      <tt>false</tt>). 
      <p>A {@link Ext.DomHelper DomHelper} element spec may also be specified to create the checkbox. If 
         <tt>true</tt> is specified, the default DomHelper config object used to create the element is:
      </p>
      <pre>
         <code>{tag: 'input', type: 'checkbox', name: this.checkboxName || this.id+'-checkbox'}
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='checkboxName'>
          <xs:annotation>
            <xs:documentation>
The name to assign to the fieldset's checkbox if 
      <tt>{@link #checkboxToggle} = true</tt> (defaults to 
      <tt>'[checkbox id]-checkbox'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelWidth'>
          <xs:annotation>
            <xs:documentation>
The width of labels. This property cascades to child containers.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='fieldset' type='ext:ext.form.FieldSet' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
Standard container used for grouping items within a {@link Ext.form.FormPanel form}. 
      <pre>
         <code>var form = new Ext.FormPanel({
            title: 'Simple Form with FieldSets',
            labelWidth: 75, // label settings here cascade unless overridden
            url: 'save-form.php',
            frame:true,
            bodyStyle:'padding:5px 5px 0',
            width: 700,
            renderTo: document.body,
            layout:'column', // arrange items in columns
            defaults: {      // defaults applied to items
            layout: 'form',
            border: false,
            bodyStyle: 'padding:4px'
            },
            items: [{
            // Fieldset in Column 1
            xtype:'fieldset',
            columnWidth: 0.5,
            title: 'Fieldset 1',
            collapsible: true,
            autoHeight:true,
            defaults: {
            anchor: '-20' // leave room for error icon
            },
            defaultType: 'textfield',
            items :[{
            fieldLabel: 'Field 1'
            }, {
            fieldLabel: 'Field 2'
            }, {
            fieldLabel: 'Field 3'
            }
            ]
            },{
            // Fieldset in Column 2 - Panel inside
            xtype:'fieldset',
            title: 'Show Panel', // title, header, or checkboxToggle creates fieldset header
            autoHeight:true,
            columnWidth: 0.5,
            checkboxToggle: true,
            collapsed: true, // fieldset initially collapsed
            layout:'anchor',
            items :[{
            xtype: 'panel',
            anchor: '100%',
            title: 'Panel inside a fieldset',
            frame: true,
            height: 100
            }]
            }]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.FormPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='formId'>
          <xs:annotation>
            <xs:documentation>
(optional) The id of the FORM tag (defaults to an auto-generated id).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideLabels'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <tt>true</tt> to hide field labels by default (sets 
         <tt>display:none</tt>). Defaults to 
         <tt>false</tt>.
      </p>
      <p>Also see {@link Ext.Component}.
         <tt>{@link Ext.Component#hideLabel hideLabel}</tt>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelPad'>
          <xs:annotation>
            <xs:documentation>
The default padding in pixels for field labels (defaults to 
      <tt>5</tt>). 
      <tt>labelPad</tt> only applies if 
      <tt>{@link #labelWidth}</tt> is also specified, otherwise it will be ignored.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelWidth'>
          <xs:annotation>
            <xs:documentation>
The width of labels in pixels. This property cascades to child containers and can be overridden on any child container (e.g.,
      a fieldset can specify a different 
      <tt>labelWidth</tt> for its fields) (defaults to 
      <tt>100</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelAlign'>
          <xs:annotation>
            <xs:documentation>
The label alignment value used for the 
      <tt>text-align</tt> specification for the 
      <b>container</b>. Valid values are 
      <tt>"left</tt>", 
      <tt>"top"</tt> or 
      <tt>"right"</tt> (defaults to 
      <tt>"left"</tt>). This property cascades to child 
      <b>containers</b> and can be overridden on any child 
      <b>container</b> (e.g., a fieldset can specify a different 
      <tt>labelAlign</tt> for its fields).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='monitorValid'>
          <xs:annotation>
            <xs:documentation>
If 
      <tt>true</tt>, the form monitors its valid state 
      <b>client-side</b> and regularly fires the {@link #clientvalidation} event passing that state.
      <br></br>
      <p>When monitoring valid state, the FormPanel enables/disables any of its configured {@link #buttons} which have been configured
         with 
         <code>formBind: true</code> depending on whether the {@link Ext.form.BasicForm#isValid form is valid} or not. Defaults to 
         <tt>false</tt>
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='monitorPoll'>
          <xs:annotation>
            <xs:documentation>
The milliseconds to poll valid state, ignored if monitorValid is not true (defaults to 200)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='form' type='ext:ext.form.FormPanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>

      <p>Standard form container.</p>
      <p style="font-weight: bold">
         <u>Layout</u>
      </p>
      <p>By default, FormPanel is configured with 
         <tt>layout:'form'</tt> to use an {@link Ext.layout.FormLayout} layout manager, which styles and renders fields and labels correctly. When nesting
         additional Containers within a FormPanel, you should ensure that any descendant Containers which host input Fields use the
         {@link Ext.layout.FormLayout} layout manager.
      </p>
      <p style="font-weight: bold">
         <u>BasicForm</u>
      </p>
      <p>Although 
         <b>not listed</b> as configuration options of FormPanel, the FormPanel class accepts all of the config options required to configure its internal
         {@link Ext.form.BasicForm} for:
      </p>
      <div class="mdetail-params">
         <ul>
            <li>{@link Ext.form.BasicForm#fileUpload file uploads}</li>
            <li>functionality for {@link Ext.form.BasicForm#doAction loading, validating and submitting} the form</li>
         </ul>
      </div>
      <p>
         <b>Note</b>: If subclassing FormPanel, any configuration options for the BasicForm must be applied to the 
         <tt>
            <b>initialConfig</b>
         </tt> property of the FormPanel. Applying {@link Ext.form.BasicForm BasicForm} configuration settings to 
         <b>
            <tt>this</tt>
         </b> will 
         <b>not</b> affect the BasicForm's configuration.
      </p>
      <p style="font-weight: bold">
         <u>Form Validation</u>
      </p>
      <p>For information on form validation see the following:</p>
      <div class="mdetail-params">
         <ul>
            <li>{@link Ext.form.TextField}</li>
            <li>{@link Ext.form.VTypes}</li>
            <li>{@link Ext.form.BasicForm#doAction BasicForm.doAction 
               <b>clientValidation</b> notes}
            </li>
            <li>
               <tt>{@link Ext.form.FormPanel#monitorValid monitorValid}</tt>
            </li>
         </ul>
      </div>
      <p style="font-weight: bold">
         <u>Form Submission</u>
      </p>
      <p>By default, Ext Forms are submitted through Ajax, using {@link Ext.form.Action}. To enable normal browser submission of the
         {@link Ext.form.BasicForm BasicForm} contained in this FormPanel, see the 
         <tt>
            <b>{@link Ext.form.BasicForm#standardSubmit standardSubmit}</b>
         </tt> option.
      </p>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Hidden'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='hidden' type='ext:ext.form.Hidden' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
A basic hidden field for storing hidden values in forms that need to be passed in the form submit.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.HtmlEditor'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
            <xs:element name='fontFamilies' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of available font families
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='enableFormat'>
          <xs:annotation>
            <xs:documentation>
Enable the bold, italic and underline buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableFontSize'>
          <xs:annotation>
            <xs:documentation>
Enable the increase/decrease font size buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColors'>
          <xs:annotation>
            <xs:documentation>
Enable the fore/highlight color buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableAlignments'>
          <xs:annotation>
            <xs:documentation>
Enable the left, center, right alignment buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableLists'>
          <xs:annotation>
            <xs:documentation>
Enable the bullet and numbered list buttons. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableSourceEdit'>
          <xs:annotation>
            <xs:documentation>
Enable the switch to source edit button. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableLinks'>
          <xs:annotation>
            <xs:documentation>
Enable the create link button. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableFont'>
          <xs:annotation>
            <xs:documentation>
Enable font selection. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='createLinkText'>
          <xs:annotation>
            <xs:documentation>
The default text for the create link prompt
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultLinkValue'>
          <xs:annotation>
            <xs:documentation>
The default value for the create link prompt (defaults to http:/ /)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fontFamilies'>
          <xs:annotation>
            <xs:documentation>
An array of available font families
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultValue'>
          <xs:annotation>
            <xs:documentation>
A default value to be put into the editor to resolve focus issues (defaults to  (Zero-width space),  (Non-breaking space)
      in Opera and IE6).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='htmleditor' type='ext:ext.form.HtmlEditor' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be automatically
      hidden when needed. These are noted in the config options where appropriate. 
      <br></br>
      <br></br>The editor's toolbar buttons have tooltips defined in the {@link #buttonTips} property, but they are not enabled by default
      unless the global {@link Ext.QuickTips} singleton is {@link Ext.QuickTips#init initialized}. 
      <br></br>
      <br></br>
      <b>Note: The focus/blur and validation marking functionality inherited from Ext.form.Field is NOT supported by this editor.</b> 
      <br></br>
      <br></br>An Editor is a sensitive component that can't be used in all spots standard fields can be used. Putting an Editor within any
      element that has display set to 'none' can cause problems in Safari and Firefox due to their default iframe reloading bugs.
      
      <br></br>
      <br></br>Example usage: 
      <pre>
         <code>// Simple example rendered with default options:
            Ext.QuickTips.init();  // enable tooltips
            new Ext.form.HtmlEditor({
            renderTo: Ext.getBody(),
            width: 800,
            height: 300
            });
            
            // Passed via xtype into a container and with custom options:
            Ext.QuickTips.init();  // enable tooltips
            new Ext.Panel({
            title: 'HTML Editor',
            renderTo: Ext.getBody(),
            width: 600,
            height: 300,
            frame: true,
            layout: 'fit',
            items: {
            xtype: 'htmleditor',
            enableColors: false,
            enableAlignments: false
            }
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Label'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The plain text to display within the label (defaults to ''). If you need to include HTML tags within the label's innerHTML,
      use the {@link #html} config instead.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='forId'>
          <xs:annotation>
            <xs:documentation>
The id of the input element to which this label will be bound via the standard HTML 'for' attribute. If not specified, the
      attribute will not be added to the label.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='html'>
          <xs:annotation>
            <xs:documentation>
An HTML fragment that will be used as the label's innerHTML (defaults to ''). Note that if {@link #text} is specified it will
      take precedence and this value will be ignored.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='label' type='ext:ext.form.Label' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Basic Label field.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.NumberField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='allowDecimals'>
          <xs:annotation>
            <xs:documentation>
False to disallow decimal values (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='decimalSeparator'>
          <xs:annotation>
            <xs:documentation>
Character(s) to allow as the decimal separator (defaults to '.')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='decimalPrecision'>
          <xs:annotation>
            <xs:documentation>
The maximum precision to display after the decimal separator (defaults to 2)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowNegative'>
          <xs:annotation>
            <xs:documentation>
False to prevent entering a negative sign (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed value (defaults to Number.NEGATIVE_INFINITY)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed value (defaults to Number.MAX_VALUE)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the minimum value validation fails (defaults to "The minimum value for this field is {minValue}")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the maximum value validation fails (defaults to "The maximum value for this field is {maxValue}")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nanText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the value is not a valid number. For example, this can happen if a valid character like '.' or '-'
      is left in the field with no number (defaults to "{value} is not a valid number")
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseChars'>
          <xs:annotation>
            <xs:documentation>
The base set of characters to evaluate as valid numbers (defaults to '0123456789').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='numberfield' type='ext:ext.form.NumberField' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
Numeric text field that provides automatic keystroke filtering and numeric validation.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Radio'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Checkbox'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='radio' type='ext:ext.form.Radio' substitutionGroup='ext:checkbox'>
    <xs:annotation>
      <xs:documentation>
Single radio field. Same as Checkbox, but provided as a convenience for automatically setting the input type. Radio grouping
      is handled automatically by the browser if you give each radio in a group the same name.
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.RadioGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.CheckboxGroup'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='radiogroup' type='ext:ext.form.RadioGroup' substitutionGroup='ext:checkboxgroup'>
    <xs:annotation>
      <xs:documentation>
A grouping container for {@link Ext.form.Radio} controls.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TextArea'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='preventScrollbars'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to prevent scrollbars from appearing regardless of how much text is in the field (equivalent to setting overflow: hidden,
      defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='textarea' type='ext:ext.form.TextArea' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
Multiline text field. Can be used as a direct replacement for traditional textarea fields, plus adds support for auto-sizing.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TextField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
            <xs:element name='stripCharsRe' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to 
      <tt>null</tt>).
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='maskRe' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An input mask regular expression that will be used to filter keystrokes that do not match (defaults to 
      <tt>null</tt>)
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='validator' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A custom validation function to be called during field validation (defaults to 
      <tt>null</tt>). If specified, this function will be called first, allowing the developer to override the default validation process. This
      function will be passed the current field value and expected to return boolean 
      <tt>true</tt> if the value is valid or a string error message if invalid.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='regex' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A JavaScript RegExp object to be tested against the field value during validation (defaults to 
      <tt>null</tt>). If the test fails, the field will be marked invalid using 
      <b>
         <tt>{@link #regexText}</tt>
      </b>.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='vtypeText'>
          <xs:annotation>
            <xs:documentation>
A custom error message to display in place of the default message provided for the 
      <b>
         <code>{@link #vtype}</code>
      </b> currently set for this field (defaults to 
      <tt>''</tt>). 
      <b>Note</b>: only applies if 
      <b>
         <code>{@link #vtype}</code>
      </b> is set, else ignored.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stripCharsRe'>
          <xs:annotation>
            <xs:documentation>
A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to 
      <tt>null</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='grow'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> if this field should automatically grow and shrink to its content (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='growMin'>
          <xs:annotation>
            <xs:documentation>
The minimum width to allow when 
      <code>
         <b>{@link #grow}</b> = true
      </code> (defaults to 
      <tt>30</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='growMax'>
          <xs:annotation>
            <xs:documentation>
The maximum width to allow when 
      <code>
         <b>{@link #grow}</b> = true
      </code> (defaults to 
      <tt>800</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='vtype'>
          <xs:annotation>
            <xs:documentation>
A validation type name as defined in {@link Ext.form.VTypes} (defaults to 
      <tt>null</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maskRe'>
          <xs:annotation>
            <xs:documentation>
An input mask regular expression that will be used to filter keystrokes that do not match (defaults to 
      <tt>null</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableKeyFilter'>
          <xs:annotation>
            <xs:documentation>
Specify 
      <tt>true</tt> to disable input keystroke filtering (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlank'>
          <xs:annotation>
            <xs:documentation>
Specify 
      <tt>false</tt> to validate that the value's length is &gt; 0 (defaults to 
      <tt>true</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minLength'>
          <xs:annotation>
            <xs:documentation>
Minimum input field length required (defaults to 
      <tt>0</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxLength'>
          <xs:annotation>
            <xs:documentation>
Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide instant
      feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To restrict the
      maximum number of characters that can be entered into the field use 
      <tt>
         <b>{@link Ext.form.Field#autoCreate autoCreate}</b>
      </tt> to add any attributes you want to a field, for example:
      <pre>
         <code>var myField = new Ext.form.NumberField({
            id: 'mobile',
            anchor:'90%',
            fieldLabel: 'Mobile',
            maxLength: 16, // for validation
            autoCreate: {tag: 'input', type: 'text', size: '20', autocomplete: 'off', maxlength: '10'}
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minLengthText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the 
      <b>
         <tt>{@link #minLength minimum length}</tt>
      </b> validation fails (defaults to 
      <tt>'The minimum length for this field is {minLength}'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxLengthText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the 
      <b>
         <tt>{@link #maxLength maximum length}</tt>
      </b> validation fails (defaults to 
      <tt>'The maximum length for this field is {maxLength}'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='selectOnFocus'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to automatically select any existing field text when the field receives input focus (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='blankText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the 
      <b>
         <tt>{@link #allowBlank}</tt>
      </b> validation fails (defaults to 
      <tt>'This field is required'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='validator'>
          <xs:annotation>
            <xs:documentation>
A custom validation function to be called during field validation (defaults to 
      <tt>null</tt>). If specified, this function will be called first, allowing the developer to override the default validation process. This
      function will be passed the current field value and expected to return boolean 
      <tt>true</tt> if the value is valid or a string error message if invalid.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='regex'>
          <xs:annotation>
            <xs:documentation>
A JavaScript RegExp object to be tested against the field value during validation (defaults to 
      <tt>null</tt>). If the test fails, the field will be marked invalid using 
      <b>
         <tt>{@link #regexText}</tt>
      </b>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='regexText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if 
      <b>
         <tt>{@link #regex}</tt>
      </b> is used and the test fails during validation (defaults to 
      <tt>''</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyText'>
          <xs:annotation>
            <xs:documentation>
The default text to place into an empty field (defaults to 
      <tt>null</tt>). 
      <b>Note</b>: that this value will be submitted to the server if this field is enabled and configured with a {@link #name}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to apply to an empty field to style the 
      <b>
         <tt>{@link #emptyText}</tt>
      </b> (defaults to 
      <tt>'x-form-empty-field'</tt>). This class is automatically added and removed as needed depending on the current field value.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableKeyEvents'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to enable the proxying of key events for the HTML input field (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='textfield' type='ext:ext.form.TextField' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>

      <p>Basic text field. Can be used as a direct replacement for traditional text inputs, or as the base class for more sophisticated
         input controls (like {@link Ext.form.TextArea} and {@link Ext.form.ComboBox}).
      </p>
      <p style="font-weight: bold">
         <u>Validation</u>
      </p>
      <p>Field validation is processed in a particular order. If validation fails at any particular step the validation routine halts.</p>
      <div class="mdetail-params">
         <ul>
            <li>
               <b>1. Field specific validator</b> 
               <div class="sub-desc">
                  <p>If a field is configured with a 
                     <code>{@link Ext.form.TextField#validator validator}</code> function, it will be passed the current field value. The 
                     <code>{@link Ext.form.TextField#validator validator}</code> function is expected to return boolean 
                     <tt>true</tt> if the value is valid or return a string to represent the invalid message if invalid.
                  </p>
               </div>
            </li>
            <li>
               <b>2. Built in Validation</b> 
               <div class="sub-desc">
                  <p>Basic validation is affected with the following configuration properties:</p>
                  <pre>
                     <u>Validation</u>    
                     <u>Invalid Message</u>
                     
                     <code>{@link Ext.form.TextField#allowBlank allowBlank}    {@link Ext.form.TextField#emptyText emptyText}</code>
                     
                     <code>{@link Ext.form.TextField#minLength minLength}     {@link Ext.form.TextField#minLengthText minLengthText}</code>
                     
                     <code>{@link Ext.form.TextField#maxLength maxLength}     {@link Ext.form.TextField#maxLengthText maxLengthText}</code>
                     
                  </pre>
               </div>
            </li>
            <li>
               <b>3. Preconfigured Validation Types (VTypes)</b> 
               <div class="sub-desc">
                  <p>Using VTypes offers a convenient way to reuse validation. If a field is configured with a 
                     <code>{@link Ext.form.TextField#vtype vtype}</code>, the corresponding {@link Ext.form.VTypes VTypes} validation function will be used for validation. If invalid, either the
                     field's 
                     <code>{@link Ext.form.TextField#vtypeText vtypeText}</code> or the VTypes vtype Text property will be used for the invalid message. Keystrokes on the field will be filtered according
                     to the VTypes vtype Mask property.
                  </p>
               </div>
            </li>
            <li>
               <b>4. Field specific regex test</b> 
               <div class="sub-desc">
                  <p>Each field may also specify a 
                     <code>{@link Ext.form.TextField#regex regex}</code> test. The invalid message for this test is configured with 
                     <code>{@link Ext.form.TextField#regexText regexText}</code>.
                  </p>
               </div>
            </li>
            <li>
               <b>Alter Validation Behavior</b> 
               <div class="sub-desc">
                  <p>Validation behavior for each field can be configured:</p>
                  <ul>
                     <li>
                        <code>{@link Ext.form.TextField#invalidText invalidText}</code> : the default validation message to show if any validation step above does not provide a message when invalid
                     </li>
                     <li>
                        <code>{@link Ext.form.TextField#maskRe maskRe}</code> : filter out keystrokes before any validation occurs
                     </li>
                     <li>
                        <code>{@link Ext.form.TextField#stripCharsRe stripCharsRe}</code> : filter characters after being typed in, but before being validated
                     </li>
                     <li>
                        <code>{@link Ext.form.Field#invalidClass invalidClass}</code> : alternate style when invalid
                     </li>
                     <li>
                        <code>{@link Ext.form.Field#validateOnBlur validateOnBlur}</code>, 
                        <code>{@link Ext.form.Field#validationDelay validationDelay}</code>, and 
                        <code>{@link Ext.form.Field#validationEvent validationEvent}</code> : modify how/when validation is triggered
                     </li>
                  </ul>
               </div>
            </li>
         </ul>
      </div>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TimeField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.ComboBox'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed time. Can be either a Javascript date object with a valid time value or a string time in a valid format
      -- see {@link #format} and {@link #altFormats} (defaults to null).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed time. Can be either a Javascript date object with a valid time value or a string time in a valid format
      -- see {@link #format} and {@link #altFormats} (defaults to null).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is before minValue (defaults to 'The time in this field must be equal
      to or after {0}').
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the time is after maxValue (defaults to 'The time in this field must be equal to or before
      {0}').
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default time format string which can be overriden for localization support. The format must be valid according to {@link
      Date#parseDate} (defaults to 'g:i A', e.g., '3:15 PM'). For 24-hour time format try 'H:i' instead.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='altFormats'>
          <xs:annotation>
            <xs:documentation>
Multiple date formats separated by "|" to try when parsing a user input value and it doesn't match the defined format (defaults
      to 'g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H').
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='increment'>
          <xs:annotation>
            <xs:documentation>
The number of minutes between each time value in the list (defaults to 15).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='timefield' type='ext:ext.form.TimeField' substitutionGroup='ext:combo'>
    <xs:annotation>
      <xs:documentation>
Provides a time input field with a time dropdown and automatic time validation. Example usage: 
      <pre>
         <code>new Ext.form.TimeField({
            minValue: '9:00 AM',
            maxValue: '6:00 PM',
            increment: 30
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TriggerField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:sequence>
            <xs:element name='triggerConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.DomHelper DomHelper} config object specifying the structure of the trigger element for this Field. (Optional).</p>
      <p>Specify this when you need a customized element to act as the trigger button for a TriggerField.</p>
      <p>Note that when using this option, it is the developer's responsibility to ensure correct sizing, positioning and appearance
         of the trigger. Defaults to:
      </p>
      <pre>
         <code>{tag: "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}</code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='triggerClass'>
          <xs:annotation>
            <xs:documentation>
An additional CSS class used to style the trigger button. The trigger will always get the class 
      <tt>'x-form-trigger'</tt> by default and 
      <tt>triggerClass</tt> will be 
      <b>appended</b> if specified.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='triggerConfig'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.DomHelper DomHelper} config object specifying the structure of the trigger element for this Field. (Optional).</p>
      <p>Specify this when you need a customized element to act as the trigger button for a TriggerField.</p>
      <p>Note that when using this option, it is the developer's responsibility to ensure correct sizing, positioning and appearance
         of the trigger. Defaults to:
      </p>
      <pre>
         <code>{tag: "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}</code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideTrigger'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to hide the trigger element and display only the base text field (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='editable'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to prevent the user from typing text directly into the field, the field will only respond to a click on the trigger to set
      the value. (defaults to 
      <tt>true</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='wrapFocusClass'>
          <xs:annotation>
            <xs:documentation>
The class added to the to the wrap of the trigger element. Defaults to 
      <tt>x-trigger-wrap-focus</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='trigger' type='ext:ext.form.TriggerField' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
Provides a convenient wrapper for TextFields that adds a clickable trigger button (looks like a combobox by default). The
      trigger has no default action, so you must assign a function to implement the trigger click handler by overriding {@link #onTriggerClick}.
      You can create a TriggerField directly, as it renders exactly like a combobox for which you can provide a custom implementation.
      For example: 
      <pre>
         <code>var trigger = new Ext.form.TriggerField();
            trigger.onTriggerClick = myTriggerFn;
            trigger.applyToMarkup('my-field');
            
         </code>
      </pre>However, in general you will most likely want to use TriggerField as the base class for a reusable component. {@link Ext.form.DateField}
      and {@link Ext.form.ComboBox} are perfect examples of this.
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.EditorGridPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.grid.GridPanel'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:int' name='clicksToEdit'>
          <xs:annotation>
            <xs:documentation>

      <p>The number of clicks on a cell required to display the cell's editor (defaults to 2).</p>
      <p>Setting this option to 'auto' means that mousedown 
         <i>on the selected cell</i> starts editing that cell.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceValidation'>
          <xs:annotation>
            <xs:documentation>
True to force validation even if the value is unmodified (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoEncode'>
          <xs:annotation>
            <xs:documentation>
True to automatically HTML encode and decode values pre and post edit (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='editorgrid' type='ext:ext.grid.EditorGridPanel' substitutionGroup='ext:grid'>
    <xs:annotation>
      <xs:documentation>

      <p>This class extends the {@link Ext.grid.GridPanel GridPanel Class} to provide cell editing on selected {@link Ext.grid.Column
         columns}. The editable columns are specified by providing an {@link Ext.grid.ColumnModel#editor editor} in the {@link Ext.grid.Column
         column configuration}.
      </p>
      <p>Editability of columns may be controlled programatically by inserting an implementation of {@link Ext.grid.ColumnModel#isCellEditable
         isCellEditable} into the {@link Ext.grid.ColumnModel ColumnModel}.
      </p>
      <p>Editing is performed on the value of the 
         <i>field</i> specified by the column's 
         <tt>{@link Ext.grid.ColumnModel#dataIndex dataIndex}</tt> in the backing {@link Ext.data.Store Store} (so if you are using a {@link Ext.grid.ColumnModel#setRenderer renderer} in order
         to display transformed data, this must be accounted for).
      </p>
      <p>If a value-to-description mapping is used to render a column, then a {@link Ext.form.Field#ComboBox ComboBox} which uses the
         same {@link Ext.form.Field#valueField value}-to-{@link Ext.form.Field#displayFieldField description} mapping would be an appropriate
         editor.
      </p>If there is a more complex mismatch between the visible data in the grid, and the editable data in the {@link Edt.data.Store
      Store}, then code to transform the data both before and after editing can be injected using the {@link #beforeedit} and {@link
      #afteredit} events.
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.GridPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='cm' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Shorthand for 
      <tt>{@link #colModel}</tt>.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='colModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.grid.ColumnModel} to use when rendering the grid (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of {@link Ext.grid.Column columns} to auto create a {@link Ext.grid.ColumnModel}. The ColumnModel may be explicitly
      created via the 
      <tt>{@link #colModel}</tt> configuration property.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='loadMask' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An {@link Ext.LoadMask} config or true to mask the grid while loading. Defaults to 
      <code>false</code>.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='sm' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Shorthand for 
      <tt>{@link #selModel}</tt>.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='selModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Any subclass of {@link Ext.grid.AbstractSelectionModel} that will provide the selection model for the grid (defaults to {@link
      Ext.grid.RowSelectionModel} if not specified).
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} the grid should use as its data source (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='view' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.grid.GridView} used by the grid. This can be set before a call to {@link Ext.Component#render render()}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='viewConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A config object that will be applied to the grid's UI view. Any of the config options available for {@link Ext.grid.GridView}
      can be specified here. This option is ignored if 
      <tt>{@link #view}</tt> is specified.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='autoExpandColumn'>
          <xs:annotation>
            <xs:documentation>

      <p>The 
         <tt>{@link Ext.grid.Column#id id}</tt> of a {@link Ext.grid.Column column} in this grid that should expand to fill unused space. This value specified here can not
         be 
         <tt>0</tt>.
      </p>
      <br></br>
      <p>
         <b>Note</b>: If the Grid's {@link Ext.grid.GridView view} is configured with 
         <tt>{@link Ext.grid.GridView#forceFit forceFit}=true</tt> the 
         <tt>autoExpandColumn</tt> is ignored. See {@link Ext.grid.Column}.
         <tt>{@link Ext.grid.Column#width width}</tt> for additional details.
      </p>
      <p>See 
         <tt>{@link #autoExpandMax}</tt> and 
         <tt>{@link #autoExpandMin}</tt> also.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='autoExpandMax'>
          <xs:annotation>
            <xs:documentation>
The maximum width the 
      <tt>{@link #autoExpandColumn}</tt> can have (if enabled). Defaults to 
      <tt>1000</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='autoExpandMin'>
          <xs:annotation>
            <xs:documentation>
The minimum width the 
      <tt>{@link #autoExpandColumn}</tt> can have (if enabled). Defaults to 
      <tt>50</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='columnLines'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to add css for column separation lines. Default is 
      <tt>false</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cm'>
          <xs:annotation>
            <xs:documentation>
Shorthand for 
      <tt>{@link #colModel}</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='colModel'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.grid.ColumnModel} to use when rendering the grid (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
An array of {@link Ext.grid.Column columns} to auto create a {@link Ext.grid.ColumnModel}. The ColumnModel may be explicitly
      created via the 
      <tt>{@link #colModel}</tt> configuration property.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddGroup'>
          <xs:annotation>
            <xs:documentation>
The DD group this GridPanel belongs to. Defaults to 
      <tt>'GridDD'</tt> if not specified.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddText'>
          <xs:annotation>
            <xs:documentation>
Configures the text in the drag proxy. Defaults to: 
      <pre>
         <code>ddText : '{0} selected row{1}'
            
         </code>
      </pre>
      <tt>{0}</tt> is replaced with the number of selected rows.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferRowRender'>
          <xs:annotation>
            <xs:documentation>

      <p>Defaults to 
         <tt>true</tt> to enable deferred row rendering.
      </p>
      <p>This allows the GridPanel to be initially rendered empty, with the expensive update of the row structure deferred so that
         layouts with GridPanels appear more quickly.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableSelection'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <tt>true</tt> to disable selections in the grid. Defaults to 
         <tt>false</tt>.
      </p>
      <p>Ignored if a {@link #selModel SelectionModel} is specified.</p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnResize'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to turn off column resizing for the whole grid. Defaults to 
      <tt>true</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnHide'>
          <xs:annotation>
            <xs:documentation>
Defaults to 
      <tt>true</tt> to enable hiding of columns with the header context menu.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnMove'>
          <xs:annotation>
            <xs:documentation>
Defaults to 
      <tt>true</tt> to enable drag and drop reorder of columns. 
      <tt>false</tt> to turn off column reordering via drag drop.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDragDrop'>
          <xs:annotation>
            <xs:documentation>

      <p>Enables dragging of the selected rows of the GridPanel. Defaults to 
         <tt>false</tt>.
      </p>
      <p>Setting this to 
         <b>
            <tt>true</tt>
         </b> causes this GridPanel's {@link #getView GridView} to create an instance of {@link Ext.grid.GridDragZone}. 
         <b>Note</b>: this is available only 
         <b>after</b> the Grid has been rendered as the GridView's 
         <tt>{@link Ext.grid.GridView#dragZone dragZone}</tt> property.
      </p>
      <p>A cooperating {@link Ext.dd.DropZone DropZone} must be created who's implementations of {@link Ext.dd.DropZone#onNodeEnter
         onNodeEnter}, {@link Ext.dd.DropZone#onNodeOver onNodeOver}, {@link Ext.dd.DropZone#onNodeOut onNodeOut} and {@link Ext.dd.DropZone#onNodeDrop
         onNodeDrop} are able to process the {@link Ext.grid.GridDragZone#getDragData data} which is provided.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableHdMenu'>
          <xs:annotation>
            <xs:documentation>
Defaults to 
      <tt>true</tt> to enable the drop down button for menu in the headers.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideHeaders'>
          <xs:annotation>
            <xs:documentation>
True to hide the grid's header. Defaults to 
      <code>false</code>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadMask'>
          <xs:annotation>
            <xs:documentation>
An {@link Ext.LoadMask} config or true to mask the grid while loading. Defaults to 
      <code>false</code>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
Sets the maximum height of the grid - ignored if 
      <tt>autoHeight</tt> is not on.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minColumnWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width a column can be resized to. Defaults to 
      <tt>25</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='sm'>
          <xs:annotation>
            <xs:documentation>
Shorthand for 
      <tt>{@link #selModel}</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selModel'>
          <xs:annotation>
            <xs:documentation>
Any subclass of {@link Ext.grid.AbstractSelectionModel} that will provide the selection model for the grid (defaults to {@link
      Ext.grid.RowSelectionModel} if not specified).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} the grid should use as its data source (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='stripeRows'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to stripe the rows. Default is 
      <tt>false</tt>. 
      <p>This causes the CSS class 
         <tt>
            <b>x-grid3-row-alt</b>
         </tt> to be added to alternate rows of the grid. A default CSS rule is provided which sets a background colour, but you can override
         this with a rule which either overrides the 
         <b>background-color</b> style using the '!important' modifier, or which uses a CSS selector of higher specificity.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackMouseOver'>
          <xs:annotation>
            <xs:documentation>
True to highlight rows when the mouse is over. Default is 
      <tt>true</tt> for GridPanel, but 
      <tt>false</tt> for EditorGridPanel.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='view'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.grid.GridView} used by the grid. This can be set before a call to {@link Ext.Component#render render()}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='viewConfig'>
          <xs:annotation>
            <xs:documentation>
A config object that will be applied to the grid's UI view. Any of the config options available for {@link Ext.grid.GridView}
      can be specified here. This option is ignored if 
      <tt>{@link #view}</tt> is specified.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='grid' type='ext:ext.grid.GridPanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>

      <p>This class represents the primary interface of a component based grid control to represent data in a tabular format of rows
         and columns. The GridPanel is composed of the following:
      </p>
      <div class="mdetail-params">
         <ul>
            <li>
               <b>{@link Ext.data.Store Store}</b> : The Model holding the data records (rows)
            </li>
            <li>
               <b>{@link Ext.grid.ColumnModel Column model}</b> : Column makeup
            </li>
            <li>
               <b>{@link Ext.grid.GridView View}</b> : Encapsulates the user interface
            </li>
            <li>
               <b>{@link Ext.grid.AbstractSelectionModel selection model}</b> : Selection behavior
            </li>
         </ul>
      </div>
      <p>Example usage:</p>
      <pre>
         <code>var grid = new Ext.grid.GridPanel({
            {@link #store}: new (@link Ext.data.Store}({
            {@link Ext.data.Store#autoDestroy autoDestroy}: true,
            {@link Ext.data.Store#reader reader}: reader,
            {@link Ext.data.Store#data data}: xg.dummyData
            }),
            {@link #columns}: [
            {id: 'company', header: 'Company', width: 200, sortable: true, dataIndex: 'company'},
            {header: 'Price', width: 120, sortable: true, renderer: Ext.util.Format.usMoney, dataIndex: 'price'},
            {header: 'Change', width: 120, sortable: true, dataIndex: 'change'},
            {header: '% Change', width: 120, sortable: true, dataIndex: 'pctChange'},
            // instead of specifying renderer: Ext.util.Format.dateRenderer('m/d/Y') use xtype
            {header: 'Last Updated', width: 135, sortable: true, dataIndex: 'lastChange', xtype: 'datecolumn', format: 'M d, Y'}
            ],
            {@link #viewConfig}: {
            {@link Ext.grid.GridView#forceFit forceFit}: true,
            
            //      Return CSS class to apply to rows depending upon data values
            {@link Ext.grid.GridView#getRowClass getRowClass}: function(record, index) {
            var c = record.{@link Ext.data.Record#get get}('change');
            if (c &lt; 0) {
            return 'price-fall';
            } else if (c &gt; 0) {
            return 'price-rise';
            }
            }
            },
            {@link #sm}: new Ext.grid.RowSelectionModel({singleSelect:true}),
            width: 600,
            height: 300,
            frame: true,
            title: 'Framed with Row Selection and Horizontal Scrolling',
            iconCls: 'icon-grid'
            });
            
         </code>
      </pre>
      <p style="font-weight: bold">
         <u>Notes:</u>
      </p>
      <div class="mdetail-params">
         <ul>
            <li>Although this class inherits many configuration options from base classes, some of them (such as autoScroll, autoWidth, layout,
               items, etc) are not used by this class, and will have no effect.
            </li>
            <li>A grid 
               <b>requires</b> a width in which to scroll its columns, and a height in which to scroll its rows. These dimensions can either be set explicitly
               through the 
               <tt>{@link Ext.BoxComponent#height height}</tt> and 
               <tt>{@link Ext.BoxComponent#width width}</tt> configuration options or implicitly set by using the grid as a child item of a {@link Ext.Container Container} which will
               have a {@link Ext.Container#layout layout manager} provide the sizing of its child items (for example the Container of the
               Grid may specify 
               <tt>{@link Ext.Container#layout layout}:'fit'</tt>).
            </li>
            <li>To access the data in a Grid, it is necessary to use the data model encapsulated by the {@link #store Store}. See the {@link
               #cellclick} event for more details.
            </li>
         </ul>
      </div>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ListView'>
    <xs:complexContent>
      <xs:extension base='ext:ext.DataView'>
        <xs:sequence>
            <xs:element name='columnResize' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specify 
      <tt>true</tt> or specify a configuration object for {@link Ext.ListView.ColumnResizer} to enable the columns to be resizable (defaults
      to 
      <tt>true</tt>).
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of column configuration objects, for example: 
      <pre>
         <code>{
            align: 'right',
            dataIndex: 'size',
            header: 'Size',
            tpl: '{size:fileSize}',
            width: .35
            }
            
         </code>
      </pre>Acceptable properties for each column configuration object are: 
      <div class="mdetail-params">
         <ul>
            <li>
               <b>
                  <tt>align</tt>
               </b> : String
               <div class="sub-desc">Set the CSS text-align property of the column. Defaults to 
                  <tt>'left'</tt>.
               </div>
            </li>
            <li>
               <b>
                  <tt>dataIndex</tt>
               </b> : String
               <div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#dataIndex dataIndex} for details.</div>
            </li>
            <li>
               <b>
                  <tt>header</tt>
               </b> : String
               <div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#header header} for details.</div>
            </li>
            <li>
               <b>
                  <tt>tpl</tt>
               </b> : String
               <div class="sub-desc">Specify a string to pass as the configuration string for {@link Ext.XTemplate}. By default an {@link Ext.XTemplate} will be
                  implicitly created using the 
                  <tt>dataIndex</tt>.
               </div>
            </li>
            <li>
               <b>
                  <tt>width</tt>
               </b> : Number
               <div class="sub-desc">Percentage of the container width this column should be allocated. Columns that have no width specified will be allocated
                  with an equal percentage to fill 100% of the container width. To easily take advantage of the full container width, leave
                  the width of at least one column undefined. Note that if you do not want to take up the full width of the container, the width
                  of every column needs to be explicitly defined.
               </div>
            </li>
         </ul>
      </div>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='columnSort' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specify 
      <tt>true</tt> or specify a configuration object for {@link Ext.ListView.Sorter} to enable the columns to be sortable (defaults to 
      <tt>true</tt>).
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='internalTpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The template to be used for the header row. See {@link #tpl} for more details.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='hideHeaders'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to hide the {@link #internalTpl header row} (defaults to 
      <tt>false</tt> so the {@link #internalTpl header row} will be shown).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='reserveScrollOffset'>
          <xs:annotation>
            <xs:documentation>
By default will defer accounting for the configured 
      <b>
         <tt>{@link #scrollOffset}</tt>
      </b> for 10 milliseconds. Specify 
      <tt>true</tt> to account for the configured 
      <b>
         <tt>{@link #scrollOffset}</tt>
      </b> immediately.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollOffset'>
          <xs:annotation>
            <xs:documentation>
The amount of space to reserve for the scrollbar (defaults to 
      <tt>19</tt> pixels)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columnResize'>
          <xs:annotation>
            <xs:documentation>
Specify 
      <tt>true</tt> or specify a configuration object for {@link Ext.ListView.ColumnResizer} to enable the columns to be resizable (defaults
      to 
      <tt>true</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
An array of column configuration objects, for example: 
      <pre>
         <code>{
            align: 'right',
            dataIndex: 'size',
            header: 'Size',
            tpl: '{size:fileSize}',
            width: .35
            }
            
         </code>
      </pre>Acceptable properties for each column configuration object are: 
      <div class="mdetail-params">
         <ul>
            <li>
               <b>
                  <tt>align</tt>
               </b> : String
               <div class="sub-desc">Set the CSS text-align property of the column. Defaults to 
                  <tt>'left'</tt>.
               </div>
            </li>
            <li>
               <b>
                  <tt>dataIndex</tt>
               </b> : String
               <div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#dataIndex dataIndex} for details.</div>
            </li>
            <li>
               <b>
                  <tt>header</tt>
               </b> : String
               <div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#header header} for details.</div>
            </li>
            <li>
               <b>
                  <tt>tpl</tt>
               </b> : String
               <div class="sub-desc">Specify a string to pass as the configuration string for {@link Ext.XTemplate}. By default an {@link Ext.XTemplate} will be
                  implicitly created using the 
                  <tt>dataIndex</tt>.
               </div>
            </li>
            <li>
               <b>
                  <tt>width</tt>
               </b> : Number
               <div class="sub-desc">Percentage of the container width this column should be allocated. Columns that have no width specified will be allocated
                  with an equal percentage to fill 100% of the container width. To easily take advantage of the full container width, leave
                  the width of at least one column undefined. Note that if you do not want to take up the full width of the container, the width
                  of every column needs to be explicitly defined.
               </div>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columnSort'>
          <xs:annotation>
            <xs:documentation>
Specify 
      <tt>true</tt> or specify a configuration object for {@link Ext.ListView.Sorter} to enable the columns to be sortable (defaults to 
      <tt>true</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='internalTpl'>
          <xs:annotation>
            <xs:documentation>
The template to be used for the header row. See {@link #tpl} for more details.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='listview' type='ext:ext.ListView' substitutionGroup='ext:dataview'>
    <xs:annotation>
      <xs:documentation>

      <p>Ext.ListView is a fast and light-weight implentation of a {@link Ext.grid.GridPanel Grid} like view with the following characteristics:</p>
      <div class="mdetail-params">
         <ul>
            <li>resizable columns</li>
            <li>selectable</li>
            <li>column widths are initially proportioned by percentage based on the container width and number of columns</li>
            <li>uses templates to render the data in any required format</li>
            <li>no horizontal scrolling</li>
            <li>no editing</li>
         </ul>
      </div>
      <p>Example usage:</p>
      <pre>
         <code>// consume JSON of this form:
            {
            "images":[
            {
            "name":"dance_fever.jpg",
            "size":2067,
            "lastmod":1236974993000,
            "url":"images\/thumbs\/dance_fever.jpg"
            },
            {
            "name":"zack_sink.jpg",
            "size":2303,
            "lastmod":1236974993000,
            "url":"images\/thumbs\/zack_sink.jpg"
            }
            ]
            } 
            var store = new Ext.data.JsonStore({
            url: 'get-images.php',
            root: 'images',
            fields: [
            'name', 'url',
            {name:'size', type: 'float'},
            {name:'lastmod', type:'date', dateFormat:'timestamp'}
            ]
            });
            store.load();
            
            var listView = new Ext.ListView({
            store: store,
            multiSelect: true,
            emptyText: 'No images to display',
            reserveScrollOffset: true,
            columns: [{
            header: 'File',
            width: .5,
            dataIndex: 'name'
            },{
            header: 'Last Modified',
            width: .35, 
            dataIndex: 'lastmod',
            tpl: '{lastmod:date("m-d h:i a")}'
            },{
            header: 'Size',
            dataIndex: 'size',
            tpl: '{size:fileSize}', // format using Ext.util.Format.fileSize()
            align: 'right'
            }]
            });
            
            // put it in a Panel so it looks pretty
            var panel = new Ext.Panel({
            id:'images-view',
            width:425,
            height:250,
            collapsible:true,
            layout:'fit',
            title:'Simple ListView 
            <i>(0 items selected)</i>',
            items: listView
            });
            panel.render(document.body);
            
            // little bit of feedback
            listView.on('selectionchange', function(view, nodes){
            var l = nodes.length;
            var s = l != 1 ? 's' : '';
            panel.setTitle('Simple ListView 
            <i>('+l+' item'+s+' selected)</i>');
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.BaseItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function that will handle the click event of this menu item (optional). The handler is passed the following parameters:
      <div class="mdetail-params">
         <ul>
            <li>
               <code>b</code> : Item
               <div class="sub-desc">This menu Item.</div>
            </li>
            <li>
               <code>e</code> : EventObject
               <div class="sub-desc">The click event.</div>
            </li>
         </ul>
      </div>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (
      <tt>
         <b>this</b>
      </tt> reference) in which the handler function will be called.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
A function that will handle the click event of this menu item (optional). The handler is passed the following parameters:
      <div class="mdetail-params">
         <ul>
            <li>
               <code>b</code> : Item
               <div class="sub-desc">This menu Item.</div>
            </li>
            <li>
               <code>e</code> : EventObject
               <div class="sub-desc">The click event.</div>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (
      <tt>
         <b>this</b>
      </tt> reference) in which the handler function will be called.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='canActivate'>
          <xs:annotation>
            <xs:documentation>
True if this item can be visually activated (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
True to hide the containing menu after this item is clicked (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='clickHideDelay'>
          <xs:annotation>
            <xs:documentation>
Length of time in milliseconds to wait before hiding after a click (defaults to 100)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menubaseitem' type='ext:ext.menu.BaseItem' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
The base class for all items that render into menus. BaseItem provides default rendering, activated state management and base
      configuration options shared by all menu components.
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.CheckItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Item'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='group'>
          <xs:annotation>
            <xs:documentation>
All check items with the same group name will automatically be grouped into a single-select radio button group (defaults to
      '')
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='groupClass'>
          <xs:annotation>
            <xs:documentation>
The default CSS class to use for radio group check items (defaults to "x-menu-group-item")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='checked'>
          <xs:annotation>
            <xs:documentation>
True to initialize this checkbox as checked (defaults to false). Note that if this checkbox is part of a radio group (group
      = true) only the last item in the group that is initialized with checked = true will be rendered as checked.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menucheckitem' type='ext:ext.menu.CheckItem' substitutionGroup='ext:menuitem'>
    <xs:annotation>
      <xs:documentation>
Adds a menu item that contains a checkbox by default, but can also be part of a radio group.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.ColorMenu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Menu'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
False to continue showing the menu after a color is selected, defaults to true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='colormenu' type='ext:ext.menu.ColorMenu' substitutionGroup='ext:menu'>
    <xs:annotation>
      <xs:documentation>
A menu containing a {@link Ext.ColorPalette} Component.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.DateMenu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Menu'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
False to continue showing the menu after a date is selected, defaults to true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='datemenu' type='ext:ext.menu.DateMenu' substitutionGroup='ext:menu'>
    <xs:annotation>
      <xs:documentation>
A menu containing a {@link Ext.DatePicker} Component.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.Item'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:sequence>
            <xs:element name='menu' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (optional) Either an instance of {@link Ext.menu.Menu} or the config object for an {@link Ext.menu.Menu} which acts as the
      submenu when this item is activated.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='menu'>
          <xs:annotation>
            <xs:documentation>
(optional) Either an instance of {@link Ext.menu.Menu} or the config object for an {@link Ext.menu.Menu} which acts as the
      submenu when this item is activated.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='icon'>
          <xs:annotation>
            <xs:documentation>
The path to an icon to display in this item (defaults to Ext.BLANK_IMAGE_URL). If icon is specified {@link #iconCls} should
      not be.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
A CSS class that specifies a background image that will be used as the icon for this item (defaults to ''). If iconCls is
      specified {@link #icon} should not be.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The text to display in this item (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='href'>
          <xs:annotation>
            <xs:documentation>
The href attribute to use for the underlying anchor link (defaults to '#').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hrefTarget'>
          <xs:annotation>
            <xs:documentation>
The target attribute to use for the underlying anchor link (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='showDelay'>
          <xs:annotation>
            <xs:documentation>
Length of time in milliseconds to wait before showing this item (defaults to 200)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menuitem' type='ext:ext.menu.Item' substitutionGroup='ext:menubaseitem'>
    <xs:annotation>
      <xs:documentation>
A base class for all menu items that require menu-related functionality (like sub-menus) and are not static display items.
      Item extends the base functionality of {@link Ext.menu.BaseItem} by adding menu-specific activation and click handling.
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.Menu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:sequence>
            <xs:element name='defaultOffsets' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning according
      to the {@link #defaultAlign} configuration. Defaults to 
      <tt>[0, 0]</tt>.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width of the menu in pixels (defaults to 120)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
True or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to "sides")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='subMenuAlign'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.Element#alignTo} anchor position value to use for submenus of this menu (defaults to "tl-tr?")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultAlign'>
          <xs:annotation>
            <xs:documentation>
The default {@link Ext.Element#alignTo} anchor position value for this menu relative to its element of origin (defaults to
      "tl-bl?")
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowOtherMenus'>
          <xs:annotation>
            <xs:documentation>
True to allow multiple menus to be displayed at the same time (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ignoreParentClicks'>
          <xs:annotation>
            <xs:documentation>
True to ignore clicks on any item in this menu that is a parent item (displays a submenu) so that the submenu is not dismissed
      when clicking the parent item (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableScrolling'>
          <xs:annotation>
            <xs:documentation>
True to allow the menu container to have scroller controls if the menu is too long (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
The maximum height of the menu. Only applies when enableScrolling is set to True (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollIncrement'>
          <xs:annotation>
            <xs:documentation>
The amount to scroll the menu. Only applies when enableScrolling is set to True (defaults to 24).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showSeparator'>
          <xs:annotation>
            <xs:documentation>
True to show the icon separator. (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultOffsets'>
          <xs:annotation>
            <xs:documentation>
An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning according
      to the {@link #defaultAlign} configuration. Defaults to 
      <tt>[0, 0]</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='floating'>
          <xs:annotation>
            <xs:documentation>
May be specified as false to create a Menu which may be used as a child item of another Container instead of a free-floating
      {@link Ext.Layer Layer}. (defaults to true).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menu' type='ext:ext.menu.Menu' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>

      <p>A menu object. This is the container to which you may add menu items. Menu can also serve as a base class when you want a
         specialized menu based off of another component (like {@link Ext.menu.DateMenu} for example).
      </p>
      <p>Menus may contain either {@link Ext.menu.Item menu items}, or general {@link Ext.Component Component}s.</p>
      <p>To make a contained general {@link Ext.Component Component} line up with other {@link Ext.menu.Item menu items} specify 
         <tt>iconCls: 'no-icon'</tt>. This reserves a space for an icon, and indents the Component in line with the other menu items. See {@link Ext.form.ComboBox}.{@link
         Ext.form.ComboBox#getListParent getListParent} for an example.
      </p>
      <p>By default, Menus are absolutely positioned, floating Components. By configuring a Menu with 
         <b>
            <tt>{@link #floating}:false</tt>
         </b>, a Menu may be used as child of a Container.
      </p>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.Separator'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menuseparator' type='ext:ext.menu.Separator' substitutionGroup='ext:menubaseitem'>
    <xs:annotation>
      <xs:documentation>
Adds a separator bar to a menu, used to divide logical groups of menu items. Generally you will add one of these by using
      "-" in you call to add() or in your items config rather than creating one directly.
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.TextItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The text to display for this item (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menutextitem' type='ext:ext.menu.TextItem' substitutionGroup='ext:menubaseitem'>
    <xs:annotation>
      <xs:documentation>
Adds a static text string to a menu, usually used as either a heading or group separator.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.PagingToolbar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Toolbar'>
        <xs:sequence>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} the paging toolbar should use as its data source (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} the paging toolbar should use as its data source (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='displayInfo'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to display the displayMsg (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageSize'>
          <xs:annotation>
            <xs:documentation>
The number of records to display per page (defaults to 
      <tt>20</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='prependButtons'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to insert any configured 
      <tt>items</tt> 
      <i>before</i> the paging buttons. Defaults to 
      <tt>false</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='displayMsg'>
          <xs:annotation>
            <xs:documentation>
The paging status message to display (defaults to 
      <tt>'Displaying {0} - {1} of {2}'</tt>). Note that this string is formatted using the braced numbers 
      <tt>{0}-{2}</tt> as tokens that are replaced by the values for start, end and total respectively. These tokens should be preserved when overriding
      this string if showing those values is desired.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyMsg'>
          <xs:annotation>
            <xs:documentation>
The message to display when no records are found (defaults to 'No data to display')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='beforePageText'>
          <xs:annotation>
            <xs:documentation>
The text displayed before the input item (defaults to 
      <tt>'Page'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='afterPageText'>
          <xs:annotation>
            <xs:documentation>
Customizable piece of the default paging text (defaults to 
      <tt>'of {0}'</tt>). Note that this string is formatted using 
      <tt>{0}</tt> as a token that is replaced by the number of total pages. This token should be preserved when overriding this string if showing
      the total page count is desired.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='firstText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the first page button (defaults to 
      <tt>'First Page'</tt>). 
      <b>Note</b>: quick tips must be initialized for the quicktip to show.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prevText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the previous page button (defaults to 
      <tt>'Previous Page'</tt>). 
      <b>Note</b>: quick tips must be initialized for the quicktip to show.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nextText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the next page button (defaults to 
      <tt>'Next Page'</tt>). 
      <b>Note</b>: quick tips must be initialized for the quicktip to show.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='lastText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the last page button (defaults to 
      <tt>'Last Page'</tt>). 
      <b>Note</b>: quick tips must be initialized for the quicktip to show.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='refreshText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the Refresh button (defaults to 
      <tt>'Refresh'</tt>). 
      <b>Note</b>: quick tips must be initialized for the quicktip to show.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='paging' type='ext:ext.PagingToolbar' substitutionGroup='ext:toolbar'>
    <xs:annotation>
      <xs:documentation>

      <p>As the amount of records increases, the time required for the browser to render them increases. Paging is used to reduce the
         amount of data exchanged with the client. Note: if there are more records/rows than can be viewed in the available screen
         area, vertical scrollbars will be added.
      </p>
      <p>Paging is typically handled on the server side (see exception below). The client sends parameters to the server side, which
         the server needs to interpret and then respond with the approprate data.
      </p>
      <p>
         <b>Ext.PagingToolbar</b> is a specialized toolbar that is bound to a {@link Ext.data.Store} and provides automatic paging control. This Component
         {@link Ext.data.Store#load load}s blocks of data into the 
         <tt>{@link #store}</tt> by passing {@link Ext.data.Store#paramNames paramNames} used for paging criteria.
      </p>
      <p>PagingToolbar is typically used as one of the Grid's toolbars:</p>
      <pre>
         <code>Ext.QuickTips.init(); // to display button quicktips
            
            var myStore = new Ext.data.Store({
            ...
            });
            
            var myPageSize = 25;  // server script should only send back 25 items
            
            var grid = new Ext.grid.GridPanel({
            ...
            store: myStore,
            bbar: new Ext.PagingToolbar({
            {@link #store}: myStore,       // grid and PagingToolbar using same store
            {@link #displayInfo}: true,
            {@link #pageSize}: myPageSize,
            {@link #prependButtons}: true,
            items: [
            'text 1'
            ]
            })
            });
            
         </code>
      </pre>
      <p>To use paging, pass the paging requirements to the server when the store is first loaded.</p>
      <pre>
         <code>store.load({
            params: {
            start: 0,          // specify params for the first page load if using paging
            limit: myPageSize,
            foo:   'bar'
            }
            });
            
         </code>
      </pre>
      <p>
         <u>Paging with Local Data</u>
      </p>
      <p>Paging can also be accomplished with local data using extensions:</p>
      <div class="mdetail-params">
         <ul>
            <li>
               <a href="http://extjs.com/forum/showthread.php?t=57386">Ext.ux.data.PagingStore</a>
            </li>
            <li>Paging Memory Proxy (examples/ux/PagingMemoryProxy.js)</li>
         </ul>
      </div>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Panel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:sequence>
            <xs:element name='bodyCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.DomHelper DomHelper} element specification object may be specified for any Panel Element.</p>
      <p>By default, the Default element in the table below will be used for the html markup to create a child element with the commensurate
         Default class name (
         <tt>baseCls</tt> will be replaced by 
         <tt>{@link #baseCls}</tt>):
      </p>
      <pre>Panel      Default  Default             Custom      Additional       Additional
         Element    element  class               element     class            style
         ========   ==========================   =========   ==============   ===========
         {@link #header}     div      {@link #baseCls}+'-header'   {@link #headerCfg}   headerCssClass   headerStyle
         {@link #bwrap}      div      {@link #baseCls}+'-bwrap'     {@link #bwrapCfg}    bwrapCssClass    bwrapStyle
         + tbar     div      {@link #baseCls}+'-tbar'       {@link #tbarCfg}     tbarCssClass     tbarStyle
         + {@link #body}     div      {@link #baseCls}+'-body'       {@link #bodyCfg}     {@link #bodyCssClass}     {@link #bodyStyle}
         + bbar     div      {@link #baseCls}+'-bbar'       {@link #bbarCfg}     bbarCssClass     bbarStyle
         + {@link #footer}   div      {@link #baseCls}+'-footer'   {@link #footerCfg}   footerCssClass   footerStyle
         
      </pre>
      <p>Configuring a Custom element may be used, for example, to force the {@link #body} Element to use a different form of markup
         than is created by default. An example of this might be to {@link Ext.Element#createChild create a child} Panel containing
         a custom content, such as a header, or forcing centering of all Panel content by having the body be a &lt;center&gt; element:
      </p>
      <pre>
         <code>new Ext.Panel({
            title: 'Message Title',
            renderTo: Ext.getBody(),
            width: 200, height: 130,
            
            <b>bodyCfg</b>: {
            tag: 'center',
            cls: 'x-panel-body',  // Default class not applied if Custom element specified
            html: 'Message'
            },
            footerCfg: {
            tag: 'h2',
            cls: 'x-panel-footer'        // same as the Default class
            html: 'footer html'
            },
            footerCssClass: 'custom-footer', // additional css class, see {@link Ext.element#addClass addClass}
            footerStyle:    'background-color:red' // see {@link #bodyStyle}
            });
            
         </code>
      </pre>
      <p>The example above also explicitly creates a 
         <tt>{@link #footer}</tt> with custom markup and styling applied.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='headerCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #header}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bwrapCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bwrap}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='tbarCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #tbar}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bbarCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bbar}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='footerCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #footer}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='tbar' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>The top toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs
         to be added to the toolbar. Note that this is not available as a property after render. To access the top toolbar after render,
         use {@link #getTopToolbar}.
      </p>
      <p>
         <b>Note:</b> Although a Toolbar may contain Field components, these will 
         <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy,
         and so are not scanned to collect form items. However, the values 
         <b>will</b> be submitted because form submission parameters are collected from the DOM tree.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='bbar' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>The bottom toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button
         configs to be added to the toolbar. Note that this is not available as a property after render. To access the bottom toolbar
         after render, use {@link #getBottomToolbar}.
      </p>
      <p>
         <b>Note:</b> Although a Toolbar may contain Field components, these will 
         <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy,
         and so are not scanned to collect form items. However, the values 
         <b>will</b> be submitted because form submission parameters are collected from the DOM tree.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='fbar' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A {@link Ext.Toolbar Toolbar} object, a Toolbar config, or an array of {@link Ext.Button Button}s/{@link Ext.Button Button}
         configs, describing a {@link Ext.Toolbar Toolbar} to be rendered into this Panel's footer element.
      </p>
      <p>After render, the 
         <code>fbar</code> property will be an {@link Ext.Toolbar Toolbar} instance.
      </p>
      <p>If 
         <tt>{@link #buttons}</tt> are specified, they will supersede the 
         <tt>fbar</tt> configuration property.
      </p>The Panel's 
      <tt>{@link #buttonAlign}</tt> configuration affects the layout of these items, for example: 
      <pre>
         <code>var w = new Ext.Window({
            height: 250,
            width: 500,
            bbar: new Ext.Toolbar({
            items: [{
            text: 'bbar Left'
            },'-&gt;',{
            text: 'bbar Right'
            }]
            }),
            {@link #buttonAlign}: 'left', // anything but 'center' or 'right' and you can use "-", and "-&gt;"
            // to control the alignment of fbar items
            fbar: [{
            text: 'fbar Left'
            },'-&gt;',{
            text: 'fbar Right'
            }]
            }).show();
            
         </code>
      </pre>
      <p>
         <b>Note:</b> Although a Toolbar may contain Field components, these will 
         <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy,
         and so are not scanned to collect form items. However, the values 
         <b>will</b> be submitted because form submission parameters are collected from the DOM tree.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='buttons' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <tt>buttons</tt> will be used as 
      <tt>{@link Ext.Container#items items}</tt> for the toolbar in the footer (
      <tt>{@link #fbar}</tt>). Typically the value of this configuration property will be an array of {@link Ext.Button}s or {@link Ext.Button} configuration
      objects. If an item is configured with 
      <tt>minWidth</tt> or the Panel is configured with 
      <tt>minButtonWidth</tt>, that width will be applied to the item.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoLoad' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A valid url spec according to the Updater {@link Ext.Updater#update} method. If autoLoad is not null, the panel will attempt
      to load its contents immediately upon render.
      <p>The URL will become the default URL for this panel's {@link #body} element, so it may be {@link Ext.Element#refresh refresh}ed
         at any time.
      </p>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bodyCssClass' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Additional css class selector to be applied to the {@link #body} element in the format expected by {@link Ext.Element#addClass}
      (defaults to null). See {@link #bodyCfg}.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bodyStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom CSS styles to be applied to the {@link #body} element in the format expected by {@link Ext.Element#applyStyles} (defaults
      to null). See {@link #bodyCfg}.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='tools' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an {@link Ext.Element
      Element} referenced by a public property called 
      <tt>tools.
         <i>&lt;tool-type&gt;</i>
      </tt> 
      <p>Each tool config may contain the following properties:</p>
      <div class="mdetail-params">
         <ul>
            <li>
               <b>id</b> : String
               <div class="sub-desc">
                  <b>Required.</b> The type of tool to create. By default, this assigns a CSS class of the form 
                  <tt>x-tool-
                     <i>&lt;tool-type&gt;</i>
                  </tt> to the resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
                  The developer may implement custom tools by supplying alternate CSS rules and background images: 
                  <div style="margin-left: 2em">
                     <div>
                        <tt>toggle</tt> (Created by default when {@link #collapsible} is 
                        <tt>true</tt>)
                     </div>
                     <div>
                        <tt>close</tt>
                     </div>
                     <div>
                        <tt>minimize</tt>
                     </div>
                     <div>
                        <tt>maximize</tt>
                     </div>
                     <div>
                        <tt>restore</tt>
                     </div>
                     <div>
                        <tt>gear</tt>
                     </div>
                     <div>
                        <tt>pin</tt>
                     </div>
                     <div>
                        <tt>unpin</tt>
                     </div>
                     <div>
                        <tt>right</tt>
                     </div>
                     <div>
                        <tt>left</tt>
                     </div>
                     <div>
                        <tt>up</tt>
                     </div>
                     <div>
                        <tt>down</tt>
                     </div>
                     <div>
                        <tt>refresh</tt>
                     </div>
                     <div>
                        <tt>minus</tt>
                     </div>
                     <div>
                        <tt>plus</tt>
                     </div>
                     <div>
                        <tt>help</tt>
                     </div>
                     <div>
                        <tt>search</tt>
                     </div>
                     <div>
                        <tt>save</tt>
                     </div>
                     <div>
                        <tt>print</tt>
                     </div>
                  </div>
               </div>
            </li>
            <li>
               <b>handler</b> : Function
               <div class="sub-desc">
                  <b>Required.</b> The function to call when clicked. Arguments passed are:
                  <ul>
                     <li>
                        <b>event</b> : Ext.EventObject
                        <div class="sub-desc">The click event.</div>
                     </li>
                     <li>
                        <b>toolEl</b> : Ext.Element
                        <div class="sub-desc">The tool Element.</div>
                     </li>
                     <li>
                        <b>panel</b> : Ext.Panel
                        <div class="sub-desc">The host Panel</div>
                     </li>
                     <li>
                        <b>tc</b> : Ext.Panel
                        <div class="sub-desc">The tool configuration object</div>
                     </li>
                  </ul>
               </div>
            </li>
            <li>
               <b>stopEvent</b> : Boolean
               <div class="sub-desc">Defaults to true. Specify as false to allow click event to propagate.</div>
            </li>
            <li>
               <b>scope</b> : Object
               <div class="sub-desc">The scope in which to call the handler.</div>
            </li>
            <li>
               <b>qtip</b> : String/Object
               <div class="sub-desc">A tip string, or a config argument to {@link Ext.QuickTip#register}</div>
            </li>
            <li>
               <b>hidden</b> : Boolean
               <div class="sub-desc">True to initially render hidden.</div>
            </li>
            <li>
               <b>on</b> : Object
               <div class="sub-desc">A listener config object specifiying event listeners in the format of an argument to {@link #addListener}</div>
            </li>
         </ul>
      </div>
      <p>Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the visual button.
         Any required functionality must be provided by adding handlers that implement the necessary behavior.
      </p>
      <p>Example usage:</p>
      <pre>
         <code>tools:[{
            id:'refresh',
            qtip: 'Refresh form Data',
            // hidden:true,
            handler: function(event, toolEl, panel){
            // refresh logic
            }
            },
            {
            id:'help',
            qtip: 'Get Help',
            handler: function(event, toolEl, panel){
            // whatever
            }
            }]
            
         </code>
      </pre>
      <p>For the custom id of 
         <tt>'help'</tt> define two relevant css classes with a link to a 15x15 image:
      </p>
      <pre>
         <code>.x-tool-help {background-image: url(images/help.png);}
            .x-tool-help-over {background-image: url(images/help_over.png);}
            // if using an image sprite:
            .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
            .x-tool-help-over {background-position:-15px 0;}
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='toolTemplate' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>A Template used to create {@link #tools} in the {@link #header} Element. Defaults to:</p>
      <pre>
         <code>new Ext.Template('&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;')</code>
      </pre>
      <p>This may may be overridden to provide a custom DOM structure for tools based upon a more complex XTemplate. The template's
         data is a single tool configuration object (Not the entire Array) as specified in {@link #tools}. In the following example
         an &lt;a&gt; tag is used to provide a visual indication when hovering over the tool:
      </p>
      <pre>
         <code>var win = new Ext.Window({
            tools: [{
            id: 'download',
            href: '/MyPdfDoc.pdf'
            }],
            toolTemplate: new Ext.XTemplate(
            '&lt;tpl if="id==\'download\'"&gt;',
            '&lt;a class="x-tool x-tool-pdf" href="{href}"&gt;&lt;/a&gt;',
            '&lt;/tpl&gt;',
            '&lt;tpl if="id!=\'download\'"&gt;',
            '&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;',
            '&lt;/tpl&gt;'
            ),
            width:500,
            height:300,
            closeAction:'hide'
            });
         </code>
      </pre>
      <p>Note that the CSS class "x-tool-pdf" should have an associated style rule which provides an appropriate background image,
         something like:
      </p>
      <pre>
         <code>a.x-tool-pdf {background-image: url(../shared/extjs/images/pdf.gif)!important;}
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='floating' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>This property is used to configure the underlying {@link Ext.Layer}. Acceptable values for this configuration property are:</p>
      <div class="mdetail-params">
         <ul>
            <li>
               <b>
                  <tt>false</tt>
               </b> : 
               <b>Default.</b>
               <div class="sub-desc">Display the panel inline where it is rendered.</div>
            </li>
            <li>
               <b>
                  <tt>true</tt>
               </b> : 
               <div class="sub-desc">Float the panel (absolute position it with automatic shimming and shadow).
                  <div style="margin-left: 2em">
                     <div class="sub-desc">Setting floating to true will create an Ext.Layer for this panel and display the panel at negative offsets so that it is hidden.</div>
                     <div class="sub-desc">Since the panel will be absolute positioned, the position must be set explicitly 
                        <i>after</i> render (e.g., 
                        <tt>myPanel.setPosition(100,100);</tt>).
                     </div>
                     <div class="sub-desc">
                        <b>Note</b>: when floating a panel you should always assign a fixed width, otherwise it will be auto width and will expand to fill to
                        the right edge of the viewport.
                     </div>
                  </div>
               </div>
            </li>
            <li>
               <b>
                  <tt>{@link Ext.Layer object}</tt>
               </b> : 
               <div class="sub-desc">The specified object will be used as the configuration object for the {@link Ext.Layer} that will be created.</div>
            </li>
         </ul>
      </div>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='html' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An HTML fragment, or a {@link Ext.DomHelper DomHelper} specification to use as the panel's body content (defaults to '').
      The HTML content is added by the Panel's {@link #afterRender} method, and so the document will not contain this HTML at the
      time the {@link #render} event is fired. This content is inserted into the body 
      <i>before</i> any configured {@link #contentEl} is appended.
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='keys' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A {@link Ext.KeyMap} config object (in the format expected by {@link Ext.KeyMap#addBinding} used to assign custom key handling
      to this panel (defaults to 
      <tt>null</tt>).
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='draggable' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>
         <tt>true</tt> to enable dragging of this Panel (defaults to 
         <tt>false</tt>).
      </p>
      <p>For custom drag/drop implementations, an 
         <b>Ext.Panel.DD</b> config could also be passed in this config instead of 
         <tt>true</tt>. Ext.Panel.DD is an internal, undocumented class which moves a proxy Element around in place of the Panel's element, but
         provides no other behaviour during dragging or on drop. It is a subclass of {@link Ext.dd.DragSource}, so behaviour may be
         added by implementing the interface methods of {@link Ext.dd.DragDrop} e.g.:
      </p>
      <pre>
         <code>new Ext.Panel({
            title: 'Drag me',
            x: 100,
            y: 100,
            renderTo: Ext.getBody(),
            floating: true,
            frame: true,
            width: 400,
            height: 200,
            draggable: {
            //      Config option of Ext.Panel.DD class.
            //      It's a floating Panel, so do not show a placeholder proxy in the original position.
            insertProxy: false,
            
            //      Called for each mousemove event while dragging the DD object.
            onDrag : function(e){
            //          Record the x,y position of the drag proxy so that we can
            //          position the Panel at end of drag.
            var pel = this.proxy.getEl();
            this.x = pel.getLeft(true);
            this.y = pel.getTop(true);
            
            //          Keep the Shadow aligned if there is one.
            var s = this.panel.getEl().shadow;
            if (s) {
            s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
            }
            },
            
            //      Called on the mouseup event.
            endDrag : function(e){
            this.panel.setPosition(this.x, this.y);
            }
            }
            }).show();
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='bodyCfg'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.DomHelper DomHelper} element specification object may be specified for any Panel Element.</p>
      <p>By default, the Default element in the table below will be used for the html markup to create a child element with the commensurate
         Default class name (
         <tt>baseCls</tt> will be replaced by 
         <tt>{@link #baseCls}</tt>):
      </p>
      <pre>Panel      Default  Default             Custom      Additional       Additional
         Element    element  class               element     class            style
         ========   ==========================   =========   ==============   ===========
         {@link #header}     div      {@link #baseCls}+'-header'   {@link #headerCfg}   headerCssClass   headerStyle
         {@link #bwrap}      div      {@link #baseCls}+'-bwrap'     {@link #bwrapCfg}    bwrapCssClass    bwrapStyle
         + tbar     div      {@link #baseCls}+'-tbar'       {@link #tbarCfg}     tbarCssClass     tbarStyle
         + {@link #body}     div      {@link #baseCls}+'-body'       {@link #bodyCfg}     {@link #bodyCssClass}     {@link #bodyStyle}
         + bbar     div      {@link #baseCls}+'-bbar'       {@link #bbarCfg}     bbarCssClass     bbarStyle
         + {@link #footer}   div      {@link #baseCls}+'-footer'   {@link #footerCfg}   footerCssClass   footerStyle
         
      </pre>
      <p>Configuring a Custom element may be used, for example, to force the {@link #body} Element to use a different form of markup
         than is created by default. An example of this might be to {@link Ext.Element#createChild create a child} Panel containing
         a custom content, such as a header, or forcing centering of all Panel content by having the body be a &lt;center&gt; element:
      </p>
      <pre>
         <code>new Ext.Panel({
            title: 'Message Title',
            renderTo: Ext.getBody(),
            width: 200, height: 130,
            
            <b>bodyCfg</b>: {
            tag: 'center',
            cls: 'x-panel-body',  // Default class not applied if Custom element specified
            html: 'Message'
            },
            footerCfg: {
            tag: 'h2',
            cls: 'x-panel-footer'        // same as the Default class
            html: 'footer html'
            },
            footerCssClass: 'custom-footer', // additional css class, see {@link Ext.element#addClass addClass}
            footerStyle:    'background-color:red' // see {@link #bodyStyle}
            });
            
         </code>
      </pre>
      <p>The example above also explicitly creates a 
         <tt>{@link #footer}</tt> with custom markup and styling applied.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='headerCfg'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #header}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bwrapCfg'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bwrap}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tbarCfg'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #tbar}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bbarCfg'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bbar}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='footerCfg'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #footer}
         Element. See 
         <tt>{@link #bodyCfg}</tt> also.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='closable'>
          <xs:annotation>
            <xs:documentation>
Panels themselves do not directly support being closed, but some Panel subclasses do (like {@link Ext.Window}) or a Panel
      Class within an {@link Ext.TabPanel}. Specify 
      <tt>true</tt> to enable closing in such situations. Defaults to 
      <tt>false</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tbar'>
          <xs:annotation>
            <xs:documentation>

      <p>The top toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs
         to be added to the toolbar. Note that this is not available as a property after render. To access the top toolbar after render,
         use {@link #getTopToolbar}.
      </p>
      <p>
         <b>Note:</b> Although a Toolbar may contain Field components, these will 
         <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy,
         and so are not scanned to collect form items. However, the values 
         <b>will</b> be submitted because form submission parameters are collected from the DOM tree.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bbar'>
          <xs:annotation>
            <xs:documentation>

      <p>The bottom toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button
         configs to be added to the toolbar. Note that this is not available as a property after render. To access the bottom toolbar
         after render, use {@link #getBottomToolbar}.
      </p>
      <p>
         <b>Note:</b> Although a Toolbar may contain Field components, these will 
         <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy,
         and so are not scanned to collect form items. However, the values 
         <b>will</b> be submitted because form submission parameters are collected from the DOM tree.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fbar'>
          <xs:annotation>
            <xs:documentation>

      <p>A {@link Ext.Toolbar Toolbar} object, a Toolbar config, or an array of {@link Ext.Button Button}s/{@link Ext.Button Button}
         configs, describing a {@link Ext.Toolbar Toolbar} to be rendered into this Panel's footer element.
      </p>
      <p>After render, the 
         <code>fbar</code> property will be an {@link Ext.Toolbar Toolbar} instance.
      </p>
      <p>If 
         <tt>{@link #buttons}</tt> are specified, they will supersede the 
         <tt>fbar</tt> configuration property.
      </p>The Panel's 
      <tt>{@link #buttonAlign}</tt> configuration affects the layout of these items, for example: 
      <pre>
         <code>var w = new Ext.Window({
            height: 250,
            width: 500,
            bbar: new Ext.Toolbar({
            items: [{
            text: 'bbar Left'
            },'-&gt;',{
            text: 'bbar Right'
            }]
            }),
            {@link #buttonAlign}: 'left', // anything but 'center' or 'right' and you can use "-", and "-&gt;"
            // to control the alignment of fbar items
            fbar: [{
            text: 'fbar Left'
            },'-&gt;',{
            text: 'fbar Right'
            }]
            }).show();
            
         </code>
      </pre>
      <p>
         <b>Note:</b> Although a Toolbar may contain Field components, these will 
         <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy,
         and so are not scanned to collect form items. However, the values 
         <b>will</b> be submitted because form submission parameters are collected from the DOM tree.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='header'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to create the Panel's header element explicitly, 
      <tt>false</tt> to skip creating it. If a 
      <tt>{@link #title}</tt> is set the header will be created automatically, otherwise it will not. If a 
      <tt>{@link #title}</tt> is set but 
      <tt>header</tt> is explicitly set to 
      <tt>false</tt>, the header will not be rendered.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='footer'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to create the footer element explicitly, false to skip creating it. The footer will be created automatically if 
      <tt>{@link #buttons}</tt> or a 
      <tt>{@link #fbar}</tt> have been configured. See 
      <tt>{@link #bodyCfg}</tt> for an example.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='title'>
          <xs:annotation>
            <xs:documentation>
The title text to be used as innerHTML (html tags are accepted) to display in the panel 
      <tt>{@link #header}</tt> (defaults to ''). When a 
      <tt>title</tt> is specified the 
      <tt>{@link #header}</tt> element will automatically be created and displayed unless {@link #header} is explicitly set to 
      <tt>false</tt>. If you do not want to specify a 
      <tt>title</tt> at config time, but you may want one later, you must either specify a non-empty 
      <tt>title</tt> (a blank space ' ' will do) or 
      <tt>header:true</tt> so that the container element will get created.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttons'>
          <xs:annotation>
            <xs:documentation>

      <tt>buttons</tt> will be used as 
      <tt>{@link Ext.Container#items items}</tt> for the toolbar in the footer (
      <tt>{@link #fbar}</tt>). Typically the value of this configuration property will be an array of {@link Ext.Button}s or {@link Ext.Button} configuration
      objects. If an item is configured with 
      <tt>minWidth</tt> or the Panel is configured with 
      <tt>minButtonWidth</tt>, that width will be applied to the item.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoLoad'>
          <xs:annotation>
            <xs:documentation>
A valid url spec according to the Updater {@link Ext.Updater#update} method. If autoLoad is not null, the panel will attempt
      to load its contents immediately upon render.
      <p>The URL will become the default URL for this panel's {@link #body} element, so it may be {@link Ext.Element#refresh refresh}ed
         at any time.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='frame'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> by default to render with plain 1px square borders. 
      <tt>true</tt> to render with 9 elements, complete with custom rounded corners (also see {@link Ext.Element#boxWrap}). 
      <p>The template generated for each condition is depicted below:</p>
      <pre>
         <code>
            // frame = false
            &lt;div id="developer-specified-id-goes-here" class="x-panel"&gt;
            
            &lt;div class="x-panel-header"&gt;&lt;span class="x-panel-header-text"&gt;Title: (frame:false)&lt;/span&gt;&lt;/div&gt;
            
            &lt;div class="x-panel-bwrap"&gt;
            &lt;div class="x-panel-body"&gt;&lt;p&gt;html value goes here&lt;/p&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;/div&gt;
            
            // frame = true (create 9 elements)
            &lt;div id="developer-specified-id-goes-here" class="x-panel"&gt;
            &lt;div class="x-panel-tl"&gt;&lt;div class="x-panel-tr"&gt;&lt;div class="x-panel-tc"&gt;
            &lt;div class="x-panel-header"&gt;&lt;span class="x-panel-header-text"&gt;Title: (frame:true)&lt;/span&gt;&lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
            
            &lt;div class="x-panel-bwrap"&gt;
            &lt;div class="x-panel-ml"&gt;&lt;div class="x-panel-mr"&gt;&lt;div class="x-panel-mc"&gt;
            &lt;div class="x-panel-body"&gt;&lt;p&gt;html value goes here&lt;/p&gt;&lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
            
            &lt;div class="x-panel-bl"&gt;&lt;div class="x-panel-br"&gt;&lt;div class="x-panel-bc"/&gt;
            &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
            &lt;/div&gt;
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='border'>
          <xs:annotation>
            <xs:documentation>
True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border is
      a 2px wide inset border, but this can be further altered by setting {@link #bodyBorder} to false.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='bodyBorder'>
          <xs:annotation>
            <xs:documentation>
True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only applies
      when {@link #border} == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset border,
      giving the entire body element an inset appearance.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bodyCssClass'>
          <xs:annotation>
            <xs:documentation>
Additional css class selector to be applied to the {@link #body} element in the format expected by {@link Ext.Element#addClass}
      (defaults to null). See {@link #bodyCfg}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bodyStyle'>
          <xs:annotation>
            <xs:documentation>
Custom CSS styles to be applied to the {@link #body} element in the format expected by {@link Ext.Element#applyStyles} (defaults
      to null). See {@link #bodyCfg}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). 
      <p>An example of specifying a custom icon class would be something like:</p>
      <pre>
         <code>// specify the property in the config for the class:
            ...
            iconCls: 'my-icon'
            
            // css class that specifies background image to be used as the icon image:
            .my-icon { background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapsible'>
          <xs:annotation>
            <xs:documentation>
True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header tool
      button area, false to keep the panel statically sized with no button (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tools'>
          <xs:annotation>
            <xs:documentation>
An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an {@link Ext.Element
      Element} referenced by a public property called 
      <tt>tools.
         <i>&lt;tool-type&gt;</i>
      </tt> 
      <p>Each tool config may contain the following properties:</p>
      <div class="mdetail-params">
         <ul>
            <li>
               <b>id</b> : String
               <div class="sub-desc">
                  <b>Required.</b> The type of tool to create. By default, this assigns a CSS class of the form 
                  <tt>x-tool-
                     <i>&lt;tool-type&gt;</i>
                  </tt> to the resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
                  The developer may implement custom tools by supplying alternate CSS rules and background images: 
                  <div style="margin-left: 2em">
                     <div>
                        <tt>toggle</tt> (Created by default when {@link #collapsible} is 
                        <tt>true</tt>)
                     </div>
                     <div>
                        <tt>close</tt>
                     </div>
                     <div>
                        <tt>minimize</tt>
                     </div>
                     <div>
                        <tt>maximize</tt>
                     </div>
                     <div>
                        <tt>restore</tt>
                     </div>
                     <div>
                        <tt>gear</tt>
                     </div>
                     <div>
                        <tt>pin</tt>
                     </div>
                     <div>
                        <tt>unpin</tt>
                     </div>
                     <div>
                        <tt>right</tt>
                     </div>
                     <div>
                        <tt>left</tt>
                     </div>
                     <div>
                        <tt>up</tt>
                     </div>
                     <div>
                        <tt>down</tt>
                     </div>
                     <div>
                        <tt>refresh</tt>
                     </div>
                     <div>
                        <tt>minus</tt>
                     </div>
                     <div>
                        <tt>plus</tt>
                     </div>
                     <div>
                        <tt>help</tt>
                     </div>
                     <div>
                        <tt>search</tt>
                     </div>
                     <div>
                        <tt>save</tt>
                     </div>
                     <div>
                        <tt>print</tt>
                     </div>
                  </div>
               </div>
            </li>
            <li>
               <b>handler</b> : Function
               <div class="sub-desc">
                  <b>Required.</b> The function to call when clicked. Arguments passed are:
                  <ul>
                     <li>
                        <b>event</b> : Ext.EventObject
                        <div class="sub-desc">The click event.</div>
                     </li>
                     <li>
                        <b>toolEl</b> : Ext.Element
                        <div class="sub-desc">The tool Element.</div>
                     </li>
                     <li>
                        <b>panel</b> : Ext.Panel
                        <div class="sub-desc">The host Panel</div>
                     </li>
                     <li>
                        <b>tc</b> : Ext.Panel
                        <div class="sub-desc">The tool configuration object</div>
                     </li>
                  </ul>
               </div>
            </li>
            <li>
               <b>stopEvent</b> : Boolean
               <div class="sub-desc">Defaults to true. Specify as false to allow click event to propagate.</div>
            </li>
            <li>
               <b>scope</b> : Object
               <div class="sub-desc">The scope in which to call the handler.</div>
            </li>
            <li>
               <b>qtip</b> : String/Object
               <div class="sub-desc">A tip string, or a config argument to {@link Ext.QuickTip#register}</div>
            </li>
            <li>
               <b>hidden</b> : Boolean
               <div class="sub-desc">True to initially render hidden.</div>
            </li>
            <li>
               <b>on</b> : Object
               <div class="sub-desc">A listener config object specifiying event listeners in the format of an argument to {@link #addListener}</div>
            </li>
         </ul>
      </div>
      <p>Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the visual button.
         Any required functionality must be provided by adding handlers that implement the necessary behavior.
      </p>
      <p>Example usage:</p>
      <pre>
         <code>tools:[{
            id:'refresh',
            qtip: 'Refresh form Data',
            // hidden:true,
            handler: function(event, toolEl, panel){
            // refresh logic
            }
            },
            {
            id:'help',
            qtip: 'Get Help',
            handler: function(event, toolEl, panel){
            // whatever
            }
            }]
            
         </code>
      </pre>
      <p>For the custom id of 
         <tt>'help'</tt> define two relevant css classes with a link to a 15x15 image:
      </p>
      <pre>
         <code>.x-tool-help {background-image: url(images/help.png);}
            .x-tool-help-over {background-image: url(images/help_over.png);}
            // if using an image sprite:
            .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
            .x-tool-help-over {background-position:-15px 0;}
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toolTemplate'>
          <xs:annotation>
            <xs:documentation>

      <p>A Template used to create {@link #tools} in the {@link #header} Element. Defaults to:</p>
      <pre>
         <code>new Ext.Template('&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;')</code>
      </pre>
      <p>This may may be overridden to provide a custom DOM structure for tools based upon a more complex XTemplate. The template's
         data is a single tool configuration object (Not the entire Array) as specified in {@link #tools}. In the following example
         an &lt;a&gt; tag is used to provide a visual indication when hovering over the tool:
      </p>
      <pre>
         <code>var win = new Ext.Window({
            tools: [{
            id: 'download',
            href: '/MyPdfDoc.pdf'
            }],
            toolTemplate: new Ext.XTemplate(
            '&lt;tpl if="id==\'download\'"&gt;',
            '&lt;a class="x-tool x-tool-pdf" href="{href}"&gt;&lt;/a&gt;',
            '&lt;/tpl&gt;',
            '&lt;tpl if="id!=\'download\'"&gt;',
            '&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;',
            '&lt;/tpl&gt;'
            ),
            width:500,
            height:300,
            closeAction:'hide'
            });
         </code>
      </pre>
      <p>Note that the CSS class "x-tool-pdf" should have an associated style rule which provides an appropriate background image,
         something like:
      </p>
      <pre>
         <code>a.x-tool-pdf {background-image: url(../shared/extjs/images/pdf.gif)!important;}
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideCollapseTool'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to hide the expand/collapse toggle button when 
      <code>{@link #collapsible} == true</code>, 
      <tt>false</tt> to display it (defaults to 
      <tt>false</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='titleCollapse'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to allow expanding and collapsing the panel (when 
      <tt>{@link #collapsible} = true</tt>) by clicking anywhere in the header bar, 
      <tt>false</tt>) to allow it only by clicking to tool button (defaults to 
      <tt>false</tt>)). If this panel is a child item of a border layout also see the {@link Ext.layout.BorderLayout.Region BorderLayout.Region}
      
      <tt>{@link Ext.layout.BorderLayout.Region#floatable floatable}</tt> config option.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoScroll'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to use overflow:'auto' on the panel's body element and show scroll bars automatically when necessary, 
      <tt>false</tt> to clip any overflowing content (defaults to 
      <tt>false</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='floating'>
          <xs:annotation>
            <xs:documentation>

      <p>This property is used to configure the underlying {@link Ext.Layer}. Acceptable values for this configuration property are:</p>
      <div class="mdetail-params">
         <ul>
            <li>
               <b>
                  <tt>false</tt>
               </b> : 
               <b>Default.</b>
               <div class="sub-desc">Display the panel inline where it is rendered.</div>
            </li>
            <li>
               <b>
                  <tt>true</tt>
               </b> : 
               <div class="sub-desc">Float the panel (absolute position it with automatic shimming and shadow).
                  <div style="margin-left: 2em">
                     <div class="sub-desc">Setting floating to true will create an Ext.Layer for this panel and display the panel at negative offsets so that it is hidden.</div>
                     <div class="sub-desc">Since the panel will be absolute positioned, the position must be set explicitly 
                        <i>after</i> render (e.g., 
                        <tt>myPanel.setPosition(100,100);</tt>).
                     </div>
                     <div class="sub-desc">
                        <b>Note</b>: when floating a panel you should always assign a fixed width, otherwise it will be auto width and will expand to fill to
                        the right edge of the viewport.
                     </div>
                  </div>
               </div>
            </li>
            <li>
               <b>
                  <tt>{@link Ext.Layer object}</tt>
               </b> : 
               <div class="sub-desc">The specified object will be used as the configuration object for the {@link Ext.Layer} that will be created.</div>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> (or a valid Ext.Shadow {@link Ext.Shadow#mode} value) to display a shadow behind the panel, 
      <tt>false</tt> to display no shadow (defaults to 
      <tt>'sides'</tt>). Note that this option only applies when 
      <tt>{@link #floating} = true</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='shadowOffset'>
          <xs:annotation>
            <xs:documentation>
The number of pixels to offset the shadow if displayed (defaults to 
      <tt>4</tt>). Note that this option only applies when 
      <tt>{@link #floating} = true</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='shim'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to disable the iframe shim in browsers which need one (defaults to 
      <tt>true</tt>). Note that this option only applies when 
      <tt>{@link #floating} = true</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='html'>
          <xs:annotation>
            <xs:documentation>
An HTML fragment, or a {@link Ext.DomHelper DomHelper} specification to use as the panel's body content (defaults to '').
      The HTML content is added by the Panel's {@link #afterRender} method, and so the document will not contain this HTML at the
      time the {@link #render} event is fired. This content is inserted into the body 
      <i>before</i> any configured {@link #contentEl} is appended.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='contentEl'>
          <xs:annotation>
            <xs:documentation>

      <p>Specify the 
         <tt>id</tt> of an existing HTML node to use as the panel's body content (defaults to '').
      </p>
      <div>
         <ul>
            <li>
               <b>Description</b> : 
               <div style="margin-left: 2em">This config option is used to take an existing HTML element and place it in the body of a new panel (it simply moves the specified
                  DOM element into the body element of the Panel 
                  <i>when the Panel is rendered</i> to use as the content (it is not going to be the actual panel itself).
               </div>
            </li>
            <li>
               <b>Notes</b> : 
               <div style="margin-left: 2em">
                  <div class="sub-desc">The specified HTML Element is appended to the Panel's {@link #body} Element by the Panel's {@link #afterRender} method 
                     <i>after any configured {@link #html HTML} has been inserted</i>, and so the document will not contain this HTML at the time the {@link #render} event is fired.
                  </div>
                  <div class="sub-desc">The specified HTML element used will not participate in any layout scheme that the Panel may use. It's just HTML. Layouts
                     operate on child items.
                  </div>
                  <div class="sub-desc">Add either the 
                     <tt>x-hidden</tt> or the 
                     <tt>x-hide-display</tt> CSS class to prevent a brief flicker of the content before it is rendered to the panel.
                  </div>
               </div>
            </li>
         </ul>
      </div>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='keys'>
          <xs:annotation>
            <xs:documentation>
A {@link Ext.KeyMap} config object (in the format expected by {@link Ext.KeyMap#addBinding} used to assign custom key handling
      to this panel (defaults to 
      <tt>null</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='draggable'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <tt>true</tt> to enable dragging of this Panel (defaults to 
         <tt>false</tt>).
      </p>
      <p>For custom drag/drop implementations, an 
         <b>Ext.Panel.DD</b> config could also be passed in this config instead of 
         <tt>true</tt>. Ext.Panel.DD is an internal, undocumented class which moves a proxy Element around in place of the Panel's element, but
         provides no other behaviour during dragging or on drop. It is a subclass of {@link Ext.dd.DragSource}, so behaviour may be
         added by implementing the interface methods of {@link Ext.dd.DragDrop} e.g.:
      </p>
      <pre>
         <code>new Ext.Panel({
            title: 'Drag me',
            x: 100,
            y: 100,
            renderTo: Ext.getBody(),
            floating: true,
            frame: true,
            width: 400,
            height: 200,
            draggable: {
            //      Config option of Ext.Panel.DD class.
            //      It's a floating Panel, so do not show a placeholder proxy in the original position.
            insertProxy: false,
            
            //      Called for each mousemove event while dragging the DD object.
            onDrag : function(e){
            //          Record the x,y position of the drag proxy so that we can
            //          position the Panel at end of drag.
            var pel = this.proxy.getEl();
            this.x = pel.getLeft(true);
            this.y = pel.getTop(true);
            
            //          Keep the Shadow aligned if there is one.
            var s = this.panel.getEl().shadow;
            if (s) {
            s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
            }
            },
            
            //      Called on the mouseup event.
            endDrag : function(e){
            this.panel.setPosition(this.x, this.y);
            }
            }
            }).show();
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tabTip'>
          <xs:annotation>
            <xs:documentation>
A string to be used as innerHTML (html tags are accepted) to show in a tooltip when mousing over the tab of a Ext.Panel which
      is an item of a {@link Ext.TabPanel}. {@link Ext.QuickTips}.init() must be called in order for the tips to render.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseCls'>
          <xs:annotation>
            <xs:documentation>
The base CSS class to apply to this panel's element (defaults to 
      <tt>'x-panel'</tt>). 
      <p>Another option available by default is to specify 
         <tt>'x-plain'</tt> which strips all styling except for required attributes for Ext layouts to function (e.g. overflow:hidden). See 
         <tt>{@link #unstyled}</tt> also.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='collapsedCls'>
          <xs:annotation>
            <xs:documentation>
A CSS class to add to the panel's element after it has been collapsed (defaults to 
      <tt>'x-panel-collapsed'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maskDisabled'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to mask the panel when it is {@link #disabled}, 
      <tt>false</tt> to not mask it (defaults to 
      <tt>true</tt>). Either way, the panel will always tell its contained elements to disable themselves when it is disabled, but masking the
      panel can provide an additional visual cue that the panel is disabled.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animCollapse'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to animate the transition when the panel is collapsed, 
      <tt>false</tt> to skip the animation (defaults to 
      <tt>true</tt> if the {@link Ext.Fx} class is available, otherwise 
      <tt>false</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='headerAsText'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to display the panel 
      <tt>{@link #title}</tt> in the 
      <tt>{@link #header}</tt>, 
      <tt>false</tt> to hide it (defaults to 
      <tt>true</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttonAlign'>
          <xs:annotation>
            <xs:documentation>
The alignment of any {@link #buttons} added to this panel. Valid values are 
      <tt>'right'</tt>, 
      <tt>'left'</tt> and 
      <tt>'center'</tt> (defaults to 
      <tt>'right'</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapsed'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to render the panel collapsed, 
      <tt>false</tt> to render it expanded (defaults to 
      <tt>false</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapseFirst'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's title
      bar, 
      <tt>false</tt> to render it last (defaults to 
      <tt>true</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minButtonWidth'>
          <xs:annotation>
            <xs:documentation>
Minimum width in pixels of all {@link #buttons} in this panel (defaults to 
      <tt>75</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='unstyled'>
          <xs:annotation>
            <xs:documentation>
Overrides the 
      <tt>{@link #baseCls}</tt> setting to 
      <tt>{@link #baseCls} = 'x-plain'</tt> which renders the panel unstyled except for required attributes for Ext layouts to function (e.g. overflow:hidden).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='elements'>
          <xs:annotation>
            <xs:documentation>
A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated automatically
      based on the items added to the panel at config time, but sometimes it might be useful to make sure a structural element is
      rendered even if not specified at config time (for example, you may want to add a button or toolbar dynamically after the
      panel has been rendered). Adding those elements to this list will allocate the required placeholders in the panel when it
      is rendered. Valid values are
      <div class="mdetail-params">
         <ul>
            <li>
               <tt>header</tt>
            </li>
            <li>
               <tt>tbar</tt> (top bar)
            </li>
            <li>
               <tt>body</tt>
            </li>
            <li>
               <tt>bbar</tt> (bottom bar)
            </li>
            <li>
               <tt>footer</tt>
            </li>
         </ul>
      </div>Defaults to '
      <tt>body</tt>'.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='preventBodyReset'>
          <xs:annotation>
            <xs:documentation>
Defaults to 
      <tt>false</tt>. When set to 
      <tt>true</tt>, an extra css class 
      <tt>'x-panel-normal'</tt> will be added to the panel's element, effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html)
      to the Panel's 
      <b>body</b> element (not the header, footer, etc.).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='panel' type='ext:ext.Panel' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>

      <p>Panel is a container that has specific functionality and structural components that make it the perfect building block for
         application-oriented user interfaces.
      </p>
      <p>Panels are, by virtue of their inheritance from {@link Ext.Container}, capable of being configured with a {@link Ext.Container#layout
         layout}, and containing child Components.
      </p>
      <p>When either specifying child {@link Ext.Component#items items} of a Panel, or dynamically {@link Ext.Container#add adding}
         Components to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether those child
         elements need to be sized using one of Ext's built-in 
         <tt>
            <b>{@link Ext.Container#layout layout}</b>
         </tt> schemes. By default, Panels use the {@link Ext.layout.ContainerLayout ContainerLayout} scheme. This simply renders child
         components, appending them one after the other inside the Container, and 
         <b>does not apply any sizing</b> at all.
      </p>
      <p>A Panel may also contain {@link #bbar bottom} and {@link #tbar top} toolbars, along with separate {@link #header}, {@link
         #footer} and {@link #body} sections (see {@link #frame} for additional information).
      </p>
      <p>Panel also provides built-in {@link #collapsible expandable and collapsible behavior}, along with a variety of {@link #tools
         prebuilt tool buttons} that can be wired up to provide other customized behavior. Panels can be easily dropped into any {@link
         Ext.Container Container} or layout, and the layout and rendering pipeline is {@link Ext.Container#add completely managed by
         the framework}.
      </p>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ProgressBar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='textEl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The element to render the progress text to (defaults to the progress bar's internal text element)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:float' name='value'>
          <xs:annotation>
            <xs:documentation>
A floating point value between 0 and 1 (e.g., .5, defaults to 0)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The progress bar text (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='textEl'>
          <xs:annotation>
            <xs:documentation>
The element to render the progress text to (defaults to the progress bar's internal text element)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseCls'>
          <xs:annotation>
            <xs:documentation>
The base CSS class to apply to the progress bar's wrapper element (defaults to 'x-progress')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>
True to animate the progress bar during transitions (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='progress' type='ext:ext.ProgressBar' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>

      <p>An updateable progress bar component. The progress bar supports two different modes: manual and automatic.</p>
      <p>In manual mode, you are responsible for showing, updating (via {@link #updateProgress}) and clearing the progress bar as needed
         from your own code. This method is most appropriate when you want to show progress throughout an operation that has predictable
         points of interest at which you can update the control.
      </p>
      <p>In automatic mode, you simply call {@link #wait} and let the progress bar run indefinitely, only clearing it once the operation
         is complete. You can optionally have the progress bar wait for a specific amount of time and then clear itself. Automatic
         mode is most appropriate for timed operations or asynchronous operations in which you have no need for indicating intermediate
         progress.
      </p>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Slider'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:int' name='value'>
          <xs:annotation>
            <xs:documentation>
The value to initialize the slider with. Defaults to minValue.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='vertical'>
          <xs:annotation>
            <xs:documentation>
Orient the Slider vertically rather than horizontally, defaults to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum value for the Slider. Defaults to 0.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum value for the Slider. Defaults to 100.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='decimalPrecision'>
          <xs:annotation>
            <xs:documentation>
. 
      <p>The number of decimal places to which to round the Slider's value. Defaults to 0.</p>
      <p>To disable rounding, configure as 
         <tt>
            <b>false</b>
         </tt>.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='keyIncrement'>
          <xs:annotation>
            <xs:documentation>
How many units to change the Slider when adjusting with keyboard navigation. Defaults to 1. If the increment config is larger,
      it will be used instead.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='increment'>
          <xs:annotation>
            <xs:documentation>
How many units to change the slider when adjusting by drag and drop. Use this option to enable 'snapping'.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='clickToChange'>
          <xs:annotation>
            <xs:documentation>
Determines whether or not clicking on the Slider axis will change the slider. Defaults to true
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>
Turn on or off animation. Defaults to true
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='slider' type='ext:ext.Slider' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Slider which supports vertical or horizontal orientation, keyboard adjustments, configurable snapping, axis clicking and animation.
      Can be added as an item to any container. Example usage: 
      <pre>
         <code>new Ext.Slider({
            renderTo: Ext.getBody(),
            width: 200,
            value: 50,
            increment: 10,
            minValue: 0,
            maxValue: 100
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.SplitButton'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Button'>
        <xs:sequence>
            <xs:element name='arrowHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the arrow button is clicked (can be used instead of click event)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='arrowHandler'>
          <xs:annotation>
            <xs:documentation>
A function called when the arrow button is clicked (can be used instead of click event)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='arrowTooltip'>
          <xs:annotation>
            <xs:documentation>
The title attribute of the arrow
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='splitbutton' type='ext:ext.SplitButton' substitutionGroup='ext:button'>
    <xs:annotation>
      <xs:documentation>
A split button that provides a built-in dropdown arrow that can fire an event separately from the default click event of the
      button. Typically this would be used to display a dropdown menu that provides additional options to the primary button action,
      but any custom handler can provide the arrowclick implementation. Example usage: 
      <pre>
         <code>// display a dropdown menu:
            new Ext.SplitButton({
            renderTo: 'button-ct', // the container id
            text: 'Options',
            handler: optionsHandler, // handle a click on the button itself
            menu: new Ext.menu.Menu({
            items: [
            // these items will render as dropdown menu items when the arrow is clicked:
            {text: 'Item 1', handler: item1Handler},
            {text: 'Item 2', handler: item2Handler}
            ]
            })
            });
            
            // Instead of showing a menu, you provide any type of custom
            // functionality you want when the dropdown arrow is clicked:
            new Ext.SplitButton({
            renderTo: 'button-ct',
            text: 'Options',
            handler: optionsHandler,
            arrowHandler: myCustomHandler
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.TabPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='itemTpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    
      <p>(Optional) A {@link Ext.Template Template} or {@link Ext.XTemplate XTemplate} which may be provided to process the data object
         returned from 
         <tt>{@link #getTemplateArgs}</tt> to produce a clickable selector element in the tab strip.
      </p>
      <p>The main element created should be a 
         <tt>&lt;li&gt;</tt> element. In order for a click event on a selector element to be connected to its item, it must take its 
         <i>id</i> from the TabPanel's native 
         <tt>{@link #getTemplateArgs}</tt>.
      </p>
      <p>The child element which contains the title text must be marked by the CSS class 
         <tt>x-tab-strip-inner</tt>.
      </p>
      <p>To enable closability, the created element should contain an element marked by the CSS class 
         <tt>x-tab-strip-close</tt>.
      </p>
      <p>If a custom 
         <tt>itemTpl</tt> is supplied, it is the developer's responsibility to create CSS style rules to create the desired appearance.
      </p>Below is an example of how to create customized tab selector items:
      <pre>
         <code>new Ext.TabPanel({
            renderTo: document.body,
            minTabWidth: 115,
            tabWidth: 135,
            enableTabScroll: true,
            width: 600,
            height: 250,
            defaults: {autoScroll:true},
            itemTpl: new Ext.XTemplate(
            '&lt;li class="{cls}" id="{id}" style="overflow:hidden"&gt;',
            '&lt;tpl if="closable"&gt;',
            '&lt;a class="x-tab-strip-close" onclick="return false;"&gt;&lt;/a&gt;',
            '&lt;/tpl&gt;',
            '&lt;a class="x-tab-right" href="#" onclick="return false;" style="padding-left:6px"&gt;',
            '&lt;em class="x-tab-left"&gt;',
            '&lt;span class="x-tab-strip-inner"&gt;',
            '&lt;img src="{src}" style="float:left;margin:3px 3px 0 0"&gt;',
            '&lt;span style="margin-left:20px" class="x-tab-strip-text {iconCls}"&gt;{text} {extra}&lt;/span&gt;',
            '&lt;/span&gt;',
            '&lt;/em&gt;',
            '&lt;/a&gt;',
            '&lt;/li&gt;'
            ),
            getTemplateArgs: function(item) {
            //      Call the native method to collect the base data. Like the ID!
            var result = Ext.TabPanel.prototype.getTemplateArgs.call(this, item);
            
            //      Add stuff used in our template
            return Ext.apply(result, {
            closable: item.closable,
            src: item.iconSrc,
            extra: item.extraText || ''
            });
            },
            items: [{
            title: 'New Tab 1',
            iconSrc: '../shared/icons/fam/grid.png',
            html: 'Tab Body 1',
            closable: true
            }, {
            title: 'New Tab 2',
            iconSrc: '../shared/icons/fam/grid.png',
            html: 'Tab Body 2',
            extraText: 'Extra stuff in the tab button'
            }]
            });
            
         </code>
      </pre>
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='layoutOnTabChange'>
          <xs:annotation>
            <xs:documentation>
Set to true to force a layout of the active tab when the tab is changed. Defaults to false. See {@link Ext.layout.CardLayout}.
      <code>{@link Ext.layout.CardLayout#layoutOnCardChange layoutOnCardChange}</code>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tabCls'>
          <xs:annotation>
            <xs:documentation>

      <b>This config option is used on 
         <u>child Components</u> of ths TabPanel.
      </b> A CSS class name applied to the tab strip item representing the child Component, allowing special styling to be applied.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferredRender'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <tt>true</tt> by default to defer the rendering of child 
         <tt>{@link Ext.Container#items items}</tt> to the browsers DOM until a tab is activated. 
         <tt>false</tt> will render all contained 
         <tt>{@link Ext.Container#items items}</tt> as soon as the {@link Ext.layout.CardLayout layout} is rendered. If there is a significant amount of content or a lot of
         heavy controls being rendered into panels that are not displayed by default, setting this to 
         <tt>true</tt> might improve performance.
      </p>
      <br></br>
      <p>The 
         <tt>deferredRender</tt> property is internally passed to the layout manager for TabPanels ({@link Ext.layout.CardLayout}) as its {@link Ext.layout.CardLayout#deferredRender}
         configuration value.
      </p>
      <br></br>
      <p>
         <b>Note</b>: leaving 
         <tt>deferredRender</tt> as 
         <tt>true</tt> means that the content within an unactivated tab will not be available. For example, this means that if the TabPanel is within
         a {@link Ext.form.FormPanel form}, then until a tab is activated, any Fields within unactivated tabs will not be rendered,
         and will therefore not be submitted and will not be available to either {@link Ext.form.BasicForm#getValues getValues} or
         {@link Ext.form.BasicForm#setValues setValues}.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabWidth'>
          <xs:annotation>
            <xs:documentation>
The initial width in pixels of each new tab (defaults to 120).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minTabWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width in pixels for each tab when {@link #resizeTabs} = true (defaults to 30).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizeTabs'>
          <xs:annotation>
            <xs:documentation>
True to automatically resize each tab so that the tabs will completely fill the tab strip (defaults to false). Setting this
      to true may cause specific widths that might be set per tab to be overridden in order to fit them all into view (although
      {@link #minTabWidth} will always be honored).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableTabScroll'>
          <xs:annotation>
            <xs:documentation>
True to enable scrolling to tabs that may be invisible due to overflowing the overall TabPanel width. Only available with
      tabPosition:'top' (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollIncrement'>
          <xs:annotation>
            <xs:documentation>
The number of pixels to scroll each time a tab scroll button is pressed (defaults to 
      <tt>100</tt>, or if 
      <tt>{@link #resizeTabs} = true</tt>, the calculated tab width). Only applies when 
      <tt>{@link #enableTabScroll} = true</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollRepeatInterval'>
          <xs:annotation>
            <xs:documentation>
Number of milliseconds between each scroll while a tab scroll button is continuously pressed (defaults to 
      <tt>400</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:float' name='scrollDuration'>
          <xs:annotation>
            <xs:documentation>
The number of milliseconds that each scroll animation should last (defaults to 
      <tt>.35</tt>). Only applies when 
      <tt>{@link #animScroll} = true</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animScroll'>
          <xs:annotation>
            <xs:documentation>
True to animate tab scrolling so that hidden tabs slide smoothly into view (defaults to 
      <tt>true</tt>). Only applies when 
      <tt>{@link #enableTabScroll} = true</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tabPosition'>
          <xs:annotation>
            <xs:documentation>
The position where the tab strip should be rendered (defaults to 
      <tt>'top'</tt>). The only other supported value is 
      <tt>'bottom'</tt>. 
      <b>Note</b>: tab scrolling is only supported for 
      <tt>tabPosition: 'top'</tt>.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoTabs'>
          <xs:annotation>
            <xs:documentation>

      <p>
         <tt>true</tt> to query the DOM for any divs with a class of 'x-tab' to be automatically converted to tabs and added to this panel (defaults
         to 
         <tt>false</tt>). Note that the query will be executed within the scope of the container element only (so that multiple tab panels from markup
         can be supported via this method).
      </p>
      <p>This method is only possible when the markup is structured correctly as a container with nested divs containing the class
         
         <tt>'x-tab'</tt>. To create TabPanels without these limitations, or to pull tab content from other elements on the page, see the example at
         the top of the class for generating tabs from markup.
      </p>
      <p>There are a couple of things to note when using this method:</p>
      <ul>
         <li>When using the 
            <tt>autoTabs</tt> config (as opposed to passing individual tab configs in the TabPanel's {@link #items} collection), you must use 
            <tt>{@link #applyTo}</tt> to correctly use the specified 
            <tt>id</tt> as the tab container. The 
            <tt>autoTabs</tt> method 
            <em>replaces</em> existing content with the TabPanel components.
         </li>
         <li>Make sure that you set 
            <tt>{@link #deferredRender}: false</tt> so that the content elements for each tab will be rendered into the TabPanel immediately upon page load, otherwise they will
            not be transformed until each tab is activated and will be visible outside the TabPanel.
         </li>
      </ul>Example usage:
      <br></br>
      <br></br> 
      <pre>
         <code>var tabs = new Ext.TabPanel({
            applyTo: 'my-tabs',
            activeTab: 0,
            deferredRender: false,
            autoTabs: true
            });
            
            // This markup will be converted to a TabPanel from the code above
            &lt;div id="my-tabs"&gt;
            &lt;div class="x-tab" title="Tab 1"&gt;A simple tab&lt;/div&gt;
            &lt;div class="x-tab" title="Tab 2"&gt;Another one&lt;/div&gt;
            &lt;/div&gt;
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoTabSelector'>
          <xs:annotation>
            <xs:documentation>
The CSS selector used to search for tabs in existing markup when 
      <tt>{@link #autoTabs} = true</tt> (defaults to 
      <tt>'div.x-tab'</tt>). This can be any valid selector supported by {@link Ext.DomQuery#select}. Note that the query will be executed within the
      scope of this tab panel only (so that multiple tab panels from markup can be supported on a page).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeTab'>
          <xs:annotation>
            <xs:documentation>
A string id or the numeric index of the tab that should be initially activated on render (defaults to none).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabMargin'>
          <xs:annotation>
            <xs:documentation>
The number of pixels of space to calculate into the sizing and scrolling of tabs. If you change the margin in CSS, you will
      need to update this value so calculations are correct with either 
      <tt>{@link #resizeTabs}</tt> or scrolling tabs. (defaults to 
      <tt>2</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='plain'>
          <xs:annotation>
            <xs:documentation>
true to render the tab strip without a background container image (defaults to 
      <tt>false</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='wheelIncrement'>
          <xs:annotation>
            <xs:documentation>
For scrolling tabs, the number of pixels to increment on mouse wheel scrolling (defaults to 
      <tt>20</tt>).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemTpl'>
          <xs:annotation>
            <xs:documentation>

      <p>(Optional) A {@link Ext.Template Template} or {@link Ext.XTemplate XTemplate} which may be provided to process the data object
         returned from 
         <tt>{@link #getTemplateArgs}</tt> to produce a clickable selector element in the tab strip.
      </p>
      <p>The main element created should be a 
         <tt>&lt;li&gt;</tt> element. In order for a click event on a selector element to be connected to its item, it must take its 
         <i>id</i> from the TabPanel's native 
         <tt>{@link #getTemplateArgs}</tt>.
      </p>
      <p>The child element which contains the title text must be marked by the CSS class 
         <tt>x-tab-strip-inner</tt>.
      </p>
      <p>To enable closability, the created element should contain an element marked by the CSS class 
         <tt>x-tab-strip-close</tt>.
      </p>
      <p>If a custom 
         <tt>itemTpl</tt> is supplied, it is the developer's responsibility to create CSS style rules to create the desired appearance.
      </p>Below is an example of how to create customized tab selector items:
      <pre>
         <code>new Ext.TabPanel({
            renderTo: document.body,
            minTabWidth: 115,
            tabWidth: 135,
            enableTabScroll: true,
            width: 600,
            height: 250,
            defaults: {autoScroll:true},
            itemTpl: new Ext.XTemplate(
            '&lt;li class="{cls}" id="{id}" style="overflow:hidden"&gt;',
            '&lt;tpl if="closable"&gt;',
            '&lt;a class="x-tab-strip-close" onclick="return false;"&gt;&lt;/a&gt;',
            '&lt;/tpl&gt;',
            '&lt;a class="x-tab-right" href="#" onclick="return false;" style="padding-left:6px"&gt;',
            '&lt;em class="x-tab-left"&gt;',
            '&lt;span class="x-tab-strip-inner"&gt;',
            '&lt;img src="{src}" style="float:left;margin:3px 3px 0 0"&gt;',
            '&lt;span style="margin-left:20px" class="x-tab-strip-text {iconCls}"&gt;{text} {extra}&lt;/span&gt;',
            '&lt;/span&gt;',
            '&lt;/em&gt;',
            '&lt;/a&gt;',
            '&lt;/li&gt;'
            ),
            getTemplateArgs: function(item) {
            //      Call the native method to collect the base data. Like the ID!
            var result = Ext.TabPanel.prototype.getTemplateArgs.call(this, item);
            
            //      Add stuff used in our template
            return Ext.apply(result, {
            closable: item.closable,
            src: item.iconSrc,
            extra: item.extraText || ''
            });
            },
            items: [{
            title: 'New Tab 1',
            iconSrc: '../shared/icons/fam/grid.png',
            html: 'Tab Body 1',
            closable: true
            }, {
            title: 'New Tab 2',
            iconSrc: '../shared/icons/fam/grid.png',
            html: 'Tab Body 2',
            extraText: 'Extra stuff in the tab button'
            }]
            });
            
         </code>
      </pre>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tabpanel' type='ext:ext.TabPanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>

      <p>A basic tab container. TabPanels can be used exactly like a standard {@link Ext.Panel} for layout purposes, but also have
         special support for containing child Components (
         <tt>{@link Ext.Container#items items}</tt>) that are managed using a {@link Ext.layout.CardLayout CardLayout layout manager}, and displayed as separate tabs.
      </p>
      <b>Note:</b> By default, a tab's close tool 
      <i>destroys</i> the child tab Component and all its descendants. This makes the child tab Component, and all its descendants 
      <b>unusable</b>. To enable re-use of a tab, configure the TabPanel with 
      <b>
         <code>{@link #autoDestroy autoDestroy: false}</code>
      </b>. 
      <p style="font-weight: bold">
         <u>TabPanel header/footer elements</u>
      </p>
      <p>TabPanels use their {@link Ext.Panel#header header} or {@link Ext.Panel#footer footer} element (depending on the {@link #tabPosition}
         configuration) to accommodate the tab selector buttons. This means that a TabPanel will not display any configured title,
         and will not display any configured header {@link Ext.Panel#tools tools}.
      </p>
      <p>To display a header, embed the TabPanel in a {@link Ext.Panel Panel} which uses 
         <b>
            <tt>{@link Ext.Container#layout layout:'fit'}</tt>
         </b>.
      </p>
      <p style="font-weight: bold">
         <u>Tab Events</u>
      </p>
      <p>There is no actual tab class  each tab is simply a {@link Ext.BoxComponent Component} such as a {@link Ext.Panel Panel}.
         However, when rendered in a TabPanel, each child Component can fire additional events that only exist for tabs and are not
         available from other Components. These events are:
      </p>
      <div>
         <ul class="mdetail-params">
            <li>
               <tt>
                  <b>{@link Ext.Panel#activate activate}</b>
               </tt> : Fires when this Component becomes the active tab.
            </li>
            <li>
               <tt>
                  <b>{@link Ext.Panel#deactivate deactivate}</b>
               </tt> : Fires when the Component that was the active tab becomes deactivated.
            </li>
         </ul>
      </div>
      <p style="font-weight: bold">
         <u>Creating TabPanels from Code</u>
      </p>
      <p>TabPanels can be created and rendered completely in code, as in this example:</p>
      <pre>
         <code>var tabs = new Ext.TabPanel({
            renderTo: Ext.getBody(),
            activeTab: 0,
            items: [{
            title: 'Tab 1',
            html: 'A simple tab'
            },{
            title: 'Tab 2',
            html: 'Another one'
            }]
            });
            
         </code>
      </pre>
      <p style="font-weight: bold">
         <u>Creating TabPanels from Existing Markup</u>
      </p>
      <p>TabPanels can also be rendered from pre-existing markup in a couple of ways.</p>
      <div>
         <ul class="mdetail-params">
            <li>Pre-Structured Markup</li>
            <li style="list-style: none">
               <div class="sub-desc">
                  <p>A container div with one or more nested tab divs with class 
                     <tt>'x-tab'</tt> can be rendered entirely from existing markup (See the {@link #autoTabs} example).
                  </p>
               </div>
            </li>
            <li>Un-Structured Markup</li>
            <li style="list-style: none">
               <div class="sub-desc">
                  <p>A TabPanel can also be rendered from markup that is not strictly structured by simply specifying by id which elements should
                     be the container and the tabs. Using this method tab content can be pulled from different elements within the page by id regardless
                     of page structure. For example:
                  </p>
                  <pre>
                     <code>var tabs = new Ext.TabPanel({
                        renderTo: 'my-tabs',
                        activeTab: 0,
                        items:[
                        {contentEl:'tab1', title:'Tab 1'},
                        {contentEl:'tab2', title:'Tab 2'}
                        ]
                        });
                        
                        // Note that the tabs do not have to be nested within the container (although they can be)
                        &lt;div id="my-tabs"&gt;&lt;/div&gt;
                        &lt;div id="tab1" class="x-hide-display"&gt;A simple tab&lt;/div&gt;
                        &lt;div id="tab2" class="x-hide-display"&gt;Another one&lt;/div&gt;
                        
                     </code>
                  </pre>Note that the tab divs in this example contain the class 
                  <tt>'x-hide-display'</tt> so that they can be rendered deferred without displaying outside the tabs. You could alternately set 
                  <tt>{@link #deferredRender} = false</tt> to render all content tabs on page load.
               </div>
            </li>
         </ul>
      </div>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Toolbar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='toolbar' type='ext:ext.Toolbar' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>

      <p>Basic Toolbar class. Although the 
         <tt>{@link Ext.Container#defaultType defaultType}</tt> for Toolbar is 
         <tt>{@link Ext.Button button}</tt>, Toolbar elements (child items for the Toolbar container) may be virtually any type of Component. Toolbar elements can be
         created explicitly via their constructors, or implicitly via their xtypes, and can be 
         <tt>{@link #add}</tt>ed dynamically.
      </p>
      <p>Some items have shortcut strings for creation:</p>
      <pre>
         <u>Shortcut</u>  
         <u>xtype</u>          
         <u>Class</u>                  
         <u>Description</u>
         '-&gt;'      'tbfill'       {@link Ext.Toolbar.Fill}       begin using the right-justified button container
         '-'       'tbseparator'  {@link Ext.Toolbar.Separator}  add a vertical separator bar between toolbar items
         ' '       'tbspacer'     {@link Ext.Toolbar.Spacer}     add horiztonal space between elements
         
      </pre>Example usage of various elements: 
      <pre>
         <code>var tb = new Ext.Toolbar({
            renderTo: document.body,
            width: 600,
            height: 100,
            items: [
            {
            // xtype: 'button', // default for Toolbars, same as 'tbbutton'
            text: 'Button'
            },
            {
            xtype: 'splitbutton', // same as 'tbsplitbutton'
            text: 'Split Button'
            },
            // begin using the right-justified button container
            '-&gt;', // same as {xtype: 'tbfill'}, // Ext.Toolbar.Fill
            {
            xtype: 'textfield',
            name: 'field1',
            emptyText: 'enter search term'
            },
            // add a vertical separator bar between toolbar items
            '-', // same as {xtype: 'tbseparator'} to create Ext.Toolbar.Separator
            'text 1', // same as {xtype: 'tbtext', text: 'text1'} to create Ext.Toolbar.TextItem
            {xtype: 'tbspacer'},// same as ' ' to create Ext.Toolbar.Spacer
            'text 2',
            {xtype: 'tbspacer', width: 50}, // add a 50px space
            'text 3'
            ]
            });
            
         </code>
      </pre>Example adding a ComboBox within a menu of a button: 
      <pre>
         <code>// ComboBox creation
            var combo = new Ext.form.ComboBox({
            store: new Ext.data.ArrayStore({
            autoDestroy: true,
            fields: ['initials', 'fullname'],
            data : [
            ['FF', 'Fred Flintstone'],
            ['BR', 'Barney Rubble']
            ]
            }),
            displayField: 'fullname',
            typeAhead: true,
            mode: 'local',
            forceSelection: true,
            triggerAction: 'all',
            emptyText: 'Select a name...',
            selectOnFocus: true,
            width: 135,
            getListParent: function() {
            return this.el.up('.x-menu');
            },
            iconCls: 'no-icon' //use iconCls if placing within menu to shift to right side of menu
            });
            
            // put ComboBox in a Menu
            var menu = new Ext.menu.Menu({
            id: 'mainMenu',
            items: [
            combo // A Field in a Menu
            ]
            });
            
            // add a Button with the menu
            tb.add({
            text:'Button w/ Menu',
            menu: menu  // assign menu by instance
            });
            tb.doLayout();
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Item'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='overflowText'>
          <xs:annotation>
            <xs:documentation>
Text to be used for the menu if the item is overflowed.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbitem' type='ext:ext.toolbar.Item' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
The base class that other non-interacting Toolbar Item classes should extend in order to get some basic common toolbar item
      functionality.
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Separator'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbseparator' type='ext:ext.toolbar.Separator' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple class that adds a vertical separator bar between toolbar items (css class:
      <tt>'xtb-sep'</tt>). Example usage: 
      <pre>
         <code>new Ext.Panel({
            tbar : [
            'Item 1',
            {xtype: 'tbseparator'}, // or '-'
            'Item 2'
            ]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Spacer'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbspacer' type='ext:ext.toolbar.Spacer' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple element that adds extra horizontal space between items in a toolbar. By default a 2px wide space is added via css
      specification:
      <pre>
         <code>.x-toolbar .xtb-spacer {
            width:2px;
            }
            
         </code>
      </pre>
      <p>Example usage:</p>
      <pre>
         <code>new Ext.Panel({
            tbar : [
            'Item 1',
            {xtype: 'tbspacer'}, // or ' '
            'Item 2',
            // space width is also configurable via javascript
            {xtype: 'tbspacer', width: 50}, // add a 50px space
            'Item 3'
            ]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Fill'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Spacer'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbfill' type='ext:ext.toolbar.Fill' substitutionGroup='ext:tbspacer'>
    <xs:annotation>
      <xs:documentation>
A non-rendering placeholder item which instructs the Toolbar's Layout to begin using the right-justified button container.
      
      <pre>
         <code>new Ext.Panel({
            tbar : [
            'Item 1',
            {xtype: 'tbfill'}, // or '-&gt;'
            'Item 2'
            ]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.TextItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbtext' type='ext:ext.toolbar.TextItem' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple class that renders text directly into a toolbar (with css class:
      <tt>'xtb-text'</tt>). Example usage: 
      <pre>
         <code>new Ext.Panel({
            tbar : [
            {xtype: 'tbtext', text: 'Item 1'} // or simply 'Item 1'
            ]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.tree.TreePanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='root' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The root node for the tree.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='dragConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom config to pass to the {@link Ext.tree.TreeDragZone} instance
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='dropConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom config to pass to the {@link Ext.tree.TreeDropZone} instance
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='selModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A tree selection model to use with this TreePanel (defaults to an {@link Ext.tree.DefaultSelectionModel})
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='loader' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A {@link Ext.tree.TreeLoader} for use with this TreePanel
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='root'>
          <xs:annotation>
            <xs:documentation>
The root node for the tree.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='rootVisible'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to hide the root node (defaults to 
      <tt>true</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lines'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to disable tree lines (defaults to 
      <tt>true</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDD'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to enable drag and drop
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDrag'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to enable just drag
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDrop'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to enable just drop
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dragConfig'>
          <xs:annotation>
            <xs:documentation>
Custom config to pass to the {@link Ext.tree.TreeDragZone} instance
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dropConfig'>
          <xs:annotation>
            <xs:documentation>
Custom config to pass to the {@link Ext.tree.TreeDropZone} instance
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddGroup'>
          <xs:annotation>
            <xs:documentation>
The DD group this TreePanel belongs to
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ddAppendOnly'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> if the tree should only allow append drops (use for trees which are sorted)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ddScroll'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to enable body scrolling
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='containerScroll'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to register this container with ScrollManager
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hlDrop'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to disable node highlight on drop (defaults to the value of {@link Ext#enableFx})
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hlColor'>
          <xs:annotation>
            <xs:documentation>
The color of the node highlight (defaults to 
      <tt>'C3DAF9'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to enable animated expand/collapse (defaults to the value of {@link Ext#enableFx})
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='singleExpand'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> if only 1 node per branch may be expanded
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selModel'>
          <xs:annotation>
            <xs:documentation>
A tree selection model to use with this TreePanel (defaults to an {@link Ext.tree.DefaultSelectionModel})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackMouseOver'>
          <xs:annotation>
            <xs:documentation>

      <tt>false</tt> to disable mouse over highlighting
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loader'>
          <xs:annotation>
            <xs:documentation>
A {@link Ext.tree.TreeLoader} for use with this TreePanel
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='pathSeparator'>
          <xs:annotation>
            <xs:documentation>
The token used to separate sub-paths in path strings (defaults to 
      <tt>'/'</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='useArrows'>
          <xs:annotation>
            <xs:documentation>

      <tt>true</tt> to use Vista-style arrows in the tree (defaults to 
      <tt>false</tt>)
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='requestMethod'>
          <xs:annotation>
            <xs:documentation>
The HTTP request method for loading data (defaults to the value of {@link Ext.Ajax#method}).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='treepanel' type='ext:ext.tree.TreePanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>

      <p>The TreePanel provides tree-structured UI representation of tree-structured data.</p>
      <p>{@link Ext.tree.TreeNode TreeNode}s added to the TreePanel may each contain metadata used by your application in their {@link
         Ext.tree.TreeNode#attributes attributes} property.
      </p>
      <p>
         <b>A TreePanel must have a {@link #root} node before it is rendered.</b> This may either be specified using the {@link #root} config option, or using the {@link #setRootNode} method.
      </p>
      <p>An example of tree rendered to an existing div:</p>
      <pre>
         <code>var tree = new Ext.tree.TreePanel({
            renderTo: 'tree-div',
            useArrows: true,
            autoScroll: true,
            animate: true,
            enableDD: true,
            containerScroll: true,
            border: false,
            // auto create TreeLoader
            dataUrl: 'get-nodes.php',
            
            root: {
            nodeType: 'async',
            text: 'Ext JS',
            draggable: false,
            id: 'source'
            }
            });
            
            tree.getRootNode().expand();
            
         </code>
      </pre>
      <p>The example above would work with a data packet similar to this:</p>
      <pre>
         <code>[{
            "text": "adapter",
            "id": "source\/adapter",
            "cls": "folder"
            }, {
            "text": "dd",
            "id": "source\/dd",
            "cls": "folder"
            }, {
            "text": "debug.js",
            "id": "source\/debug.js",
            "leaf": true,
            "cls": "file"
            }]
            
         </code>
      </pre>
      <p>An example of tree within a Viewport:</p>
      <pre>
         <code>new Ext.Viewport({
            layout: 'border',
            items: [{
            region: 'west',
            collapsible: true,
            title: 'Navigation',
            xtype: 'treepanel',
            width: 200,
            autoScroll: true,
            split: true,
            loader: new Ext.tree.TreeLoader(),
            root: new Ext.tree.AsyncTreeNode({
            expanded: true,
            children: [{
            text: 'Menu Option 1',
            leaf: true
            }, {
            text: 'Menu Option 2',
            leaf: true
            }, {
            text: 'Menu Option 3',
            leaf: true
            }]
            }),
            rootVisible: false,
            listeners: {
            click: function(n) {
            Ext.Msg.alert('Navigation Tree Click', 'You clicked: "' + n.attributes.text + '"');
            }
            }
            }, {
            region: 'center',
            xtype: 'tabpanel',
            // remaining code not shown ...
            }]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Viewport'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='deferHeight'>
          <xs:annotation>
            <xs:documentation>
@hide
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='viewport' type='ext:ext.Viewport' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>

      <p>A specialized container representing the viewable application area (the browser viewport).</p>
      <p>The Viewport renders itself to the document body, and automatically sizes itself to the size of the browser viewport and manages
         window resizing. There may only be one Viewport created in a page. Inner layouts are available by virtue of the fact that
         all {@link Ext.Panel Panel}s added to the Viewport, either through its {@link #items}, or through the items, or the {@link
         #add} method of any of its child Panels may themselves have a layout.
      </p>
      <p>The Viewport does not provide scrolling, so child Panels within the Viewport should provide for scrolling if needed using
         the {@link #autoScroll} config.
      </p>
      <p>An example showing a classic application border layout:</p>
      <pre>
         <code>new Ext.Viewport({
            layout: 'border',
            items: [{
            region: 'north',
            html: '&lt;h1 class="x-panel-header"&gt;Page Title&lt;/h1&gt;',
            autoHeight: true,
            border: false,
            margins: '0 0 5 0'
            }, {
            region: 'west',
            collapsible: true,
            title: 'Navigation',
            width: 200
            // the west region might typically utilize a {@link Ext.tree.TreePanel TreePanel} or a Panel with {@link Ext.layout.AccordionLayout
            Accordion layout} 
            }, {
            region: 'south',
            title: 'Title for Panel',
            collapsible: true,
            html: 'Information goes here',
            split: true,
            height: 100,
            minHeight: 100
            }, {
            region: 'east',
            title: 'Title for the Grid Panel',
            collapsible: true,
            split: true,
            width: 200,
            xtype: 'grid',
            // remaining grid configuration not shown ...
            // notice that the GridPanel is added directly as the region
            // it is not "overnested" inside another Panel
            }, {
            region: 'center',
            xtype: 'tabpanel', // TabPanel itself has no title
            items: {
            title: 'Default Tab',
            html: 'The first tab\'s content. Others may be added dynamically'
            }
            }]
            });
            
         </code>
      </pre>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Window'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='animateTarget' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Id or element from which the window should animate while opening (defaults to null with no animation).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='manager' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A reference to the WindowGroup that should manage this window (defaults to {@link Ext.WindowMgr}).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaultButton' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The id / index of a button or a button instance to focus when this window received the focus.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='onEsc' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Allows override of the built-in processing for the escape key. Default action is to close the Window (performing whatever
      action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is pressed, specify this as
      Ext.emptyFn (See {@link Ext#emptyFn}).
   
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='modal'>
          <xs:annotation>
            <xs:documentation>
True to make the window modal and mask everything behind it when displayed, false to display it without restricting access
      to other UI elements (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='animateTarget'>
          <xs:annotation>
            <xs:documentation>
Id or element from which the window should animate while opening (defaults to null with no animation).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='resizeHandles'>
          <xs:annotation>
            <xs:documentation>
A valid {@link Ext.Resizable} handles config string (defaults to 'all'). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='manager'>
          <xs:annotation>
            <xs:documentation>
A reference to the WindowGroup that should manage this window (defaults to {@link Ext.WindowMgr}).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultButton'>
          <xs:annotation>
            <xs:documentation>
The id / index of a button or a button instance to focus when this window received the focus.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='onEsc'>
          <xs:annotation>
            <xs:documentation>
Allows override of the built-in processing for the escape key. Default action is to close the Window (performing whatever
      action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is pressed, specify this as
      Ext.emptyFn (See {@link Ext#emptyFn}).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maximized'>
          <xs:annotation>
            <xs:documentation>
True to initially display the window in a maximized state. (Defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizable'>
          <xs:annotation>
            <xs:documentation>
True to allow user resizing at each edge and corner of the window, false to disable resizing (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='closeAction'>
          <xs:annotation>
            <xs:documentation>

      <p>The action to take when the close header tool is clicked:</p>
      <div class="mdetail-params">
         <ul>
            <li>
               <b>
                  <code>'{@link #close}'</code>
               </b> : 
               <b>Default</b>
               <div class="sub-desc">{@link #close remove} the window from the DOM and {@link Ext.Component#destroy destroy} it and all descendant Components.
                  The window will 
                  <b>not</b> be available to be redisplayed via the {@link #show} method.
               </div>
            </li>
            <li>
               <b>
                  <code>'{@link #hide}'</code>
               </b> : 
               <div class="sub-desc">{@link #hide} the window by setting visibility to hidden and applying negative offsets. The window will be available to be
                  redisplayed via the {@link #show} method.
               </div>
            </li>
         </ul>
      </div>
      <p>
         <b>Note:</b> This setting does not affect the {@link #close} method which will always {@link Ext.Component#destroy destroy} the window.
         To programatically 
         <i>hide</i> a window, call {@link #hide}.
      </p>
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrain'>
          <xs:annotation>
            <xs:documentation>
True to constrain the window within its containing element, false to allow it to fall outside of its containing element. By
      default the window will be rendered to document.body. To render and constrain the window within another element specify {@link
      #renderTo}. (defaults to false). Optionally the header only can be constrained using {@link #constrainHeader}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrainHeader'>
          <xs:annotation>
            <xs:documentation>
True to constrain the window header within its containing element (allowing the window body to fall outside of its containing
      element) or false to allow the header to fall outside its containing element (defaults to false). Optionally the entire window
      can be constrained using {@link #constrain}.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='plain'>
          <xs:annotation>
            <xs:documentation>
True to render the window body with a transparent background so that it will blend into the framing elements, false to add
      a lighter background color to visually highlight the body element and separate it more distinctly from the surrounding frame
      (defaults to false).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='minimizable'>
          <xs:annotation>
            <xs:documentation>
True to display the 'minimize' tool button and allow the user to minimize the window, false to hide the button and disallow
      minimizing the window (defaults to false). Note that this button provides no implementation -- the behavior of minimizing
      a window is implementation-specific, so the minimize event must be handled and a custom minimize behavior implemented for
      this option to be useful.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maximizable'>
          <xs:annotation>
            <xs:documentation>
True to display the 'maximize' tool button and allow the user to maximize the window, false to hide the button and disallow
      maximizing the window (defaults to false). Note that when a window is maximized, the tool button will automatically change
      to a 'restore' button with the appropriate behavior already built-in that will restore the window to its previous size.
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minHeight'>
          <xs:annotation>
            <xs:documentation>
The minimum height in pixels allowed for this window (defaults to 100). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width in pixels allowed for this window (defaults to 200). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='expandOnShow'>
          <xs:annotation>
            <xs:documentation>
True to always expand the window when it is displayed, false to keep it in its current state (which may be {@link #collapsed})
      when displayed (defaults to true).
   
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='initHidden'>
          <xs:annotation>
            <xs:documentation>
True to hide the window until show() is explicitly called (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='window' type='ext:ext.Window' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>

      <p>A specialized panel intended for use as an application window. Windows are floated, {@link #resizable}, and {@link #draggable}
         by default. Windows can be {@link #maximizable maximized} to fill the viewport, restored to their prior size, and can be {@link
         #minimize}d.
      </p>
      <p>Windows can also be linked to a {@link Ext.WindowGroup} or managed by the {@link Ext.WindowMgr} to provide grouping, activation,
         to front, to back and other application-specific behavior.
      </p>
      <p>By default, Windows will be rendered to document.body. To {@link #constrain} a Window to another element specify {@link Ext.Component#renderTo
         renderTo}.
      </p>
      <p>
         <b>Note:</b> By default, the 
         <code>{@link #closable close}</code> header tool 
         <i>destroys</i> the Window resulting in destruction of any child Components. This makes the Window object, and all its descendants 
         <b>unusable</b>. To enable re-use of a Window, use 
         <b>
            <code>{@link #closeAction closeAction: 'hide'}</code>
         </b>.
      </p>
   
      </xs:documentation>
    </xs:annotation>
  </xs:element>
</xs:schema>
